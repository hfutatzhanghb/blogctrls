<!DOCTYPE html>
<!-- saved from url=(0054)https://javadoop.com/post/AbstractQueuedSynchronizer-2 -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0">
    <title>一行一行源码分析清楚 AbstractQueuedSynchronizer (二)</title>

    <link rel="icon" href="https://javadoop.com/images/favor.ico">

    <link href="./一行一行源码分析清楚 AbstractQueuedSynchronizer (二)_files/bootstrap.min.css" rel="stylesheet">
    <link rel="stylesheet" type="text/css" href="./一行一行源码分析清楚 AbstractQueuedSynchronizer (二)_files/highlight.min.css">
    <link rel="stylesheet" type="text/css" href="./一行一行源码分析清楚 AbstractQueuedSynchronizer (二)_files/2051.css">

    <script src="./一行一行源码分析清楚 AbstractQueuedSynchronizer (二)_files/jquery.min.js"></script>
    <script src="./一行一行源码分析清楚 AbstractQueuedSynchronizer (二)_files/jquery.cookie.js"></script>
    <script src="./一行一行源码分析清楚 AbstractQueuedSynchronizer (二)_files/vue.min.js"></script>
    <script src="./一行一行源码分析清楚 AbstractQueuedSynchronizer (二)_files/bootstrap.min.js"></script>
    <script src="./一行一行源码分析清楚 AbstractQueuedSynchronizer (二)_files/highlight.min.js"></script>

    <!-- HTML5 shim and Respond.js for IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->
</head>
<body class="yellow" style="">
<div>
    <div id="wrapper">
        <nav class="hidden-xs" id="toc" data-toggle="toc" style="display: none;"><ul class="nav"><li><a href="https://javadoop.com/post/AbstractQueuedSynchronizer-2#toc0">公平锁和非公平锁</a></li><li><a href="https://javadoop.com/post/AbstractQueuedSynchronizer-2#toc1">Condition</a><ul class="nav"><li><a href="https://javadoop.com/post/AbstractQueuedSynchronizer-2#toc2">1. 将节点加入到条件队列</a></li><li><a href="https://javadoop.com/post/AbstractQueuedSynchronizer-2#toc3">2. 完全释放独占锁</a></li><li><a href="https://javadoop.com/post/AbstractQueuedSynchronizer-2#toc4">3. 等待进入阻塞队列</a></li><li><a href="https://javadoop.com/post/AbstractQueuedSynchronizer-2#toc5">4. signal 唤醒线程，转移到阻塞队列</a></li><li><a href="https://javadoop.com/post/AbstractQueuedSynchronizer-2#toc6">5. 唤醒后检查中断状态</a></li><li><a href="https://javadoop.com/post/AbstractQueuedSynchronizer-2#toc7">6. 获取独占锁</a></li><li><a href="https://javadoop.com/post/AbstractQueuedSynchronizer-2#toc8">7. 处理中断状态</a></li><li><a href="https://javadoop.com/post/AbstractQueuedSynchronizer-2#toc9">* 带超时机制的 await</a></li><li><a href="https://javadoop.com/post/AbstractQueuedSynchronizer-2#toc10">* 不抛出 InterruptedException 的 await</a></li></ul></li><li><a href="https://javadoop.com/post/AbstractQueuedSynchronizer-2#toc11">AbstractQueuedSynchronizer 独占锁的取消排队</a></li><li><a href="https://javadoop.com/post/AbstractQueuedSynchronizer-2#toc12">再说 java 线程中断和 InterruptedException 异常</a><ul class="nav"><li><a href="https://javadoop.com/post/AbstractQueuedSynchronizer-2#toc13">线程中断</a></li><li><a href="https://javadoop.com/post/AbstractQueuedSynchronizer-2#toc14">InterruptedException 概述</a></li><li><a href="https://javadoop.com/post/AbstractQueuedSynchronizer-2#toc15">处理中断</a></li></ul></li><li><a href="https://javadoop.com/post/AbstractQueuedSynchronizer-2#toc16">总结</a></li></ul></nav>
        
        <div id="content">

            
            <a id="back-to-home" href="https://javadoop.com/">
                <i class="glyphicon glyphicon-home"></i> 回首页
            </a> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;新的主题，右下角可以设置，欢迎大家提出建议。
            <div class="title">一行一行源码分析清楚 AbstractQueuedSynchronizer (二)</div>
            <div class="updateTime">更新时间：2017-07-20</div>
            <p>文章比较长，信息量比较大，建议在 pc 上阅读。文章标题是为了呼应前文，其实可以单独成文的，主要是希望读者看文章能系统看。</p>
<p>本文关注以下几点内容：</p>
<ol>
<li>深入理解 ReentrantLock 公平锁和非公平锁的区别</li>
<li>深入分析 AbstractQueuedSynchronizer 中的 ConditionObject</li>
<li>深入理解 java 线程中断和 InterruptedException 异常</li>
</ol>
<p>基本上本文把以上几点都说清楚了，我假设读者看过<a href="http://hongjiev.github.io/2017/06/16/AbstractQueuedSynchronizer/">上一篇文章中对 AbstractQueuedSynchronizer 的介绍 </a>，当然如果你已经熟悉 AQS 中的独占锁了，那也可以直接看这篇。各小节之间基本上没什么关系，大家可以只关注自己感兴趣的部分。</p>
<!-- more -->
<!-- toc -->
<ul>
<li><a href="https://javadoop.com/post/AbstractQueuedSynchronizer-2#%E5%85%AC%E5%B9%B3%E9%94%81%E5%92%8C%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81">公平锁和非公平锁</a></li>
<li><a href="https://javadoop.com/post/AbstractQueuedSynchronizer-2#Condition">Condition</a><ul>
<li><a href="https://javadoop.com/post/AbstractQueuedSynchronizer-2#1.%20%E5%B0%86%E8%8A%82%E7%82%B9%E5%8A%A0%E5%85%A5%E5%88%B0%E6%9D%A1%E4%BB%B6%E9%98%9F%E5%88%97">1. 将节点加入到条件队列</a></li>
<li><a href="https://javadoop.com/post/AbstractQueuedSynchronizer-2#2.%20%E5%AE%8C%E5%85%A8%E9%87%8A%E6%94%BE%E7%8B%AC%E5%8D%A0%E9%94%81">2. 完全释放独占锁</a></li>
<li><a href="https://javadoop.com/post/AbstractQueuedSynchronizer-2#3.%20%E7%AD%89%E5%BE%85%E8%BF%9B%E5%85%A5%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97">3. 等待进入阻塞队列</a></li>
<li><a href="https://javadoop.com/post/AbstractQueuedSynchronizer-2#4.%20signal%20%E5%94%A4%E9%86%92%E7%BA%BF%E7%A8%8B%EF%BC%8C%E8%BD%AC%E7%A7%BB%E5%88%B0%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97">4. signal 唤醒线程，转移到阻塞队列</a></li>
<li><a href="https://javadoop.com/post/AbstractQueuedSynchronizer-2#5.%20%E5%94%A4%E9%86%92%E5%90%8E%E6%A3%80%E6%9F%A5%E4%B8%AD%E6%96%AD%E7%8A%B6%E6%80%81">5. 唤醒后检查中断状态</a></li>
<li><a href="https://javadoop.com/post/AbstractQueuedSynchronizer-2#6.%20%E8%8E%B7%E5%8F%96%E7%8B%AC%E5%8D%A0%E9%94%81">6. 获取独占锁</a></li>
<li><a href="https://javadoop.com/post/AbstractQueuedSynchronizer-2#7.%20%E5%A4%84%E7%90%86%E4%B8%AD%E6%96%AD%E7%8A%B6%E6%80%81">7. 处理中断状态</a></li>
<li><a href="https://javadoop.com/post/AbstractQueuedSynchronizer-2#*%20%E5%B8%A6%E8%B6%85%E6%97%B6%E6%9C%BA%E5%88%B6%E7%9A%84%20await">* 带超时机制的 await</a></li>
<li><a href="https://javadoop.com/post/AbstractQueuedSynchronizer-2#*%20%E4%B8%8D%E6%8A%9B%E5%87%BA%20InterruptedException%20%E7%9A%84%20await">* 不抛出 InterruptedException 的 await</a></li>
</ul>
</li>
<li><a href="https://javadoop.com/post/AbstractQueuedSynchronizer-2#AbstractQueuedSynchronizer%20%E7%8B%AC%E5%8D%A0%E9%94%81%E7%9A%84%E5%8F%96%E6%B6%88%E6%8E%92%E9%98%9F">AbstractQueuedSynchronizer 独占锁的取消排队</a></li>
<li><a href="https://javadoop.com/post/AbstractQueuedSynchronizer-2#%E5%86%8D%E8%AF%B4%20java%20%E7%BA%BF%E7%A8%8B%E4%B8%AD%E6%96%AD%E5%92%8C%20InterruptedException%20%E5%BC%82%E5%B8%B8">再说 java 线程中断和 InterruptedException 异常</a><ul>
<li><a href="https://javadoop.com/post/AbstractQueuedSynchronizer-2#%E7%BA%BF%E7%A8%8B%E4%B8%AD%E6%96%AD">线程中断</a></li>
<li><a href="https://javadoop.com/post/AbstractQueuedSynchronizer-2#InterruptedException%20%E6%A6%82%E8%BF%B0">InterruptedException 概述</a></li>
<li><a href="https://javadoop.com/post/AbstractQueuedSynchronizer-2#%E5%A4%84%E7%90%86%E4%B8%AD%E6%96%AD">处理中断</a></li>
</ul>
</li>
<li><a href="https://javadoop.com/post/AbstractQueuedSynchronizer-2#%E6%80%BB%E7%BB%93">总结</a></li>
</ul>
<!-- tocstop -->
<span id="toc0"></span><h2 id="%E5%85%AC%E5%B9%B3%E9%94%81%E5%92%8C%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81">公平锁和非公平锁</h2>
<p>ReentrantLock 默认采用非公平锁，除非你在构造方法中传入参数 true 。</p>
<pre><code class="lang-java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ReentrantLock</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{
    sync = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NonfairSync();
}
<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ReentrantLock</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">boolean</span></span></span></span><span class="hljs-function"><span class="hljs-params"> fair)</span></span></span><span class="hljs-function"> </span></span>{
    sync = fair ? <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FairSync() : <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NonfairSync();
}
</code></pre>
<p>公平锁的 lock 方法：</p>
<pre><code class="lang-java hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FairSync</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Sync</span></span></span><span class="hljs-class"> </span></span>{
    <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">final</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">lock</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{
        acquire(<span class="hljs-number"><span class="hljs-number">1</span></span>);
    }
    <span class="hljs-comment"><span class="hljs-comment">// AbstractQueuedSynchronizer.acquire(int arg)</span></span>
    <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">final</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">acquire</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> arg)</span></span></span><span class="hljs-function"> </span></span>{
        <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!tryAcquire(arg) &amp;&amp;
            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))
            selfInterrupt();
    }
    <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">final</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tryAcquire</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> acquires)</span></span></span><span class="hljs-function"> </span></span>{
        <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Thread current = Thread.currentThread();
        <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> c = getState();
        <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (c == <span class="hljs-number"><span class="hljs-number">0</span></span>) {
            <span class="hljs-comment"><span class="hljs-comment">// 1. 和非公平锁相比，这里多了一个判断：是否有线程在等待</span></span>
            <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!hasQueuedPredecessors() &amp;&amp;
                compareAndSetState(<span class="hljs-number"><span class="hljs-number">0</span></span>, acquires)) {
                setExclusiveOwnerThread(current);
                <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>;
            }
        }
        <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (current == getExclusiveOwnerThread()) {
            <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> nextc = c + acquires;
            <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (nextc &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>)
                <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Error(<span class="hljs-string"><span class="hljs-string">"Maximum lock count exceeded"</span></span>);
            setState(nextc);
            <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>;
        }
        <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>;
    }
}
</code></pre>
<p>非公平锁的 lock 方法：</p>
<pre><code class="lang-java hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NonfairSync</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Sync</span></span></span><span class="hljs-class"> </span></span>{
    <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">final</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">lock</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{
        <span class="hljs-comment"><span class="hljs-comment">// 2. 和公平锁相比，这里会直接先进行一次CAS，成功就返回了</span></span>
        <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (compareAndSetState(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>))
            setExclusiveOwnerThread(Thread.currentThread());
        <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>
            acquire(<span class="hljs-number"><span class="hljs-number">1</span></span>);
    }
    <span class="hljs-comment"><span class="hljs-comment">// AbstractQueuedSynchronizer.acquire(int arg)</span></span>
    <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">final</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">acquire</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> arg)</span></span></span><span class="hljs-function"> </span></span>{
        <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!tryAcquire(arg) &amp;&amp;
            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))
            selfInterrupt();
    }
    <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">final</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tryAcquire</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> acquires)</span></span></span><span class="hljs-function"> </span></span>{
        <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> nonfairTryAcquire(acquires);
    }
}
<span class="hljs-comment"><span class="hljs-comment">/**
 * Performs non-fair tryLock.  tryAcquire is implemented in
 * subclasses, but both need nonfair try for trylock method.
 */</span></span>
<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">final</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">nonfairTryAcquire</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> acquires)</span></span></span><span class="hljs-function"> </span></span>{
    <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Thread current = Thread.currentThread();
    <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> c = getState();
    <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (c == <span class="hljs-number"><span class="hljs-number">0</span></span>) {
        <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (compareAndSetState(<span class="hljs-number"><span class="hljs-number">0</span></span>, acquires)) {
            setExclusiveOwnerThread(current);
            <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>;
        }
    }
    <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (current == getExclusiveOwnerThread()) {
        <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> nextc = c + acquires;
        <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (nextc &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-comment"><span class="hljs-comment">// overflow</span></span>
            <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Error(<span class="hljs-string"><span class="hljs-string">"Maximum lock count exceeded"</span></span>);
        setState(nextc);
        <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>;
    }
    <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>;
}
</code></pre>
<p>总结：公平锁和非公平锁只有两处不同：</p>
<ol>
<li>非公平锁在调用 lock 后，首先就会调用 CAS 进行一次抢锁，如果这个时候恰巧锁没有被占用，那么直接就获取到锁返回了。</li>
<li>非公平锁在 CAS 失败后，和公平锁一样都会进入到 tryAcquire 方法，在 tryAcquire 方法中，如果发现锁这个时候被释放了（state == 0），非公平锁会直接 CAS 抢锁，但是公平锁会判断等待队列是否有线程处于等待状态，如果有则不去抢锁，乖乖排到后面。</li>
</ol>
<p>公平锁和非公平锁就这两点区别，如果这两次 CAS 都不成功，那么后面非公平锁和公平锁是一样的，都要进入到阻塞队列等待唤醒。</p>
<p>相对来说，非公平锁会有更好的性能，因为它的吞吐量比较大。当然，非公平锁让获取锁的时间变得更加不确定，可能会导致在阻塞队列中的线程长期处于饥饿状态。</p>
<span id="toc1"></span><h2 id="Condition">Condition</h2>
<p>Tips: 这里重申一下，要看懂这个，必须要先看懂上一篇关于 <a href="http://hongjiev.github.io/2017/06/16/AbstractQueuedSynchronizer/">AbstractQueuedSynchronizer</a> 的介绍，或者你已经有相关的知识了，否则这节肯定是看不懂的。</p>
<p>我们先来看看 Condition 的使用场景，Condition 经常可以用在<strong>生产者-消费者</strong>的场景中，请看 Doug Lea 给出的这个例子：</p>
<pre><code class="lang-java hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.util.concurrent.locks.Condition;
<span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.util.concurrent.locks.Lock;
<span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.util.concurrent.locks.ReentrantLock;

<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BoundedBuffer</span></span></span><span class="hljs-class"> </span></span>{
    <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Lock lock = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ReentrantLock();
    <span class="hljs-comment"><span class="hljs-comment">// condition 依赖于 lock 来产生</span></span>
    <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Condition notFull = lock.newCondition();
    <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Condition notEmpty = lock.newCondition();

    <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Object[] items = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Object[<span class="hljs-number"><span class="hljs-number">100</span></span>];
    <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> putptr, takeptr, count;

    <span class="hljs-comment"><span class="hljs-comment">// 生产</span></span>
    <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">put</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Object x)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> InterruptedException </span></span>{
        lock.lock();
        <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> {
            <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (count == items.length)
                notFull.await();  <span class="hljs-comment"><span class="hljs-comment">// 队列已满，等待，直到 not full 才能继续生产</span></span>
            items[putptr] = x;
            <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (++putptr == items.length) putptr = <span class="hljs-number"><span class="hljs-number">0</span></span>;
            ++count;
            notEmpty.signal(); <span class="hljs-comment"><span class="hljs-comment">// 生产成功，队列已经 not empty 了，发个通知出去</span></span>
        } <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span> {
            lock.unlock();
        }
    }

    <span class="hljs-comment"><span class="hljs-comment">// 消费</span></span>
    <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Object </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">take</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> InterruptedException </span></span>{
        lock.lock();
        <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> {
            <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (count == <span class="hljs-number"><span class="hljs-number">0</span></span>)
                notEmpty.await(); <span class="hljs-comment"><span class="hljs-comment">// 队列为空，等待，直到队列 not empty，才能继续消费</span></span>
            Object x = items[takeptr];
            <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (++takeptr == items.length) takeptr = <span class="hljs-number"><span class="hljs-number">0</span></span>;
            --count;
            notFull.signal(); <span class="hljs-comment"><span class="hljs-comment">// 被我消费掉一个，队列 not full 了，发个通知出去</span></span>
            <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x;
        } <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span> {
            lock.unlock();
        }
    }
}
</code></pre>
<p><em>（<strong>ArrayBlockingQueue</strong> 采用这种方式实现了生产者-消费者，所以请只把这个例子当做学习例子，实际生产中可以直接使用 ArrayBlockingQueue）</em></p>
<p>我们常用 obj.wait()，obj.notify() 或 obj.notifyAll() 来实现相似的功能，但是，它们是基于对象的监视器锁的。需要深入了解这几个方法的读者，可以参考我的另一篇文章《<a href="http://hongjiev.github.io/2017/07/05/Threads-And-Locks-md/">深入分析 java 8 编程语言规范：Threads and Locks</a>》。而这里说的 Condition 是基于 ReentrantLock 实现的，而 ReentrantLock 是依赖于 AbstractQueuedSynchronizer 实现的。</p>
<p>在往下看之前，读者心里要有一个整体的概念。condition 是依赖于 ReentrantLock  的，不管是调用 await 进入等待还是 signal 唤醒，都必须获取到锁才能进行操作。</p>
<p>每个 ReentrantLock  实例可以通过调用多次 newCondition 产生多个 ConditionObject 的实例：</p>
<pre><code class="lang-java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">final</span></span></span><span class="hljs-function"> ConditionObject </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">newCondition</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{
    <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ConditionObject();
}
</code></pre>
<p>我们首先来看下我们关注的 Condition 的实现类 <code>AbstractQueuedSynchronizer</code> 类中的 <code>ConditionObject</code>。</p>
<pre><code class="lang-java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ConditionObject</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Condition</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">java</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">io</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Serializable</span></span></span><span class="hljs-class"> </span></span>{
        <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> serialVersionUID = <span class="hljs-number"><span class="hljs-number">1173984872572414699L</span></span>;
        <span class="hljs-comment"><span class="hljs-comment">// 条件队列的第一个节点</span></span>
          <span class="hljs-comment"><span class="hljs-comment">// 不要管这里的关键字 transient，是不参与序列化的意思</span></span>
        <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">transient</span></span> Node firstWaiter;
        <span class="hljs-comment"><span class="hljs-comment">// 条件队列的最后一个节点</span></span>
        <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">transient</span></span> Node lastWaiter;
        ......
</code></pre>
<p>在上一篇介绍 AQS 的时候，我们有一个<strong>阻塞队列</strong>，用于保存等待获取锁的线程的队列。这里我们引入另一个概念，叫<strong>条件队列</strong>（condition queue），我画了一张简单的图用来说明这个。</p>
<blockquote>
<p>这里的阻塞队列如果叫做同步队列（sync queue）其实比较贴切，不过为了和前篇呼应，我就继续使用阻塞队列了。记住这里的两个概念，<strong>阻塞队列</strong>和<strong>条件队列</strong>。</p>
</blockquote>
<p><img src="./一行一行源码分析清楚 AbstractQueuedSynchronizer (二)_files/aqs2-2.png" alt="condition-2"></p>
<blockquote>
<p>这里，我们简单回顾下 Node 的属性：</p>
<pre><code class="lang-java hljs"><span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> waitStatus; <span class="hljs-comment"><span class="hljs-comment">// 可取值 0、CANCELLED(1)、SIGNAL(-1)、CONDITION(-2)、PROPAGATE(-3)</span></span>
<span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span> Node prev;
<span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span> Node next;
<span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span> Thread thread;
Node nextWaiter;
</code></pre>
<p>prev 和 next 用于实现阻塞队列的双向链表，nextWaiter 用于实现条件队列的单向链表</p>
</blockquote>
<p>基本上，把这张图看懂，你也就知道 condition 的处理流程了。所以，我先简单解释下这图，然后再具体地解释代码实现。</p>
<ol>
<li>我们知道一个 ReentrantLock 实例可以通过多次调用 newCondition() 来产生多个 Condition 实例，这里对应 condition1 和 condition2。注意，ConditionObject 只有两个属性 firstWaiter 和 lastWaiter；</li>
</ol>
<ol>
<li>每个 condition 有一个关联的<strong>条件队列</strong>，如线程 1 调用 condition1.await() 方法即可将当前线程 1 包装成 Node 后加入到条件队列中，然后阻塞在这里，不继续往下执行，条件队列是一个单向链表；</li>
<li>调用 condition1.signal() 会将condition1 对应的<strong>条件队列</strong>的 firstWaiter 移到<strong>阻塞队列</strong>的队尾，等待获取锁，获取锁后 await 方法返回，继续往下执行。</li>
</ol>
<p>我这里说的 1、2、3 是最简单的流程，没有考虑中断、signalAll、还有带有超时参数的 await 方法等，不过把这里弄懂是这节的主要目的。</p>
<p>同时，从图中也可以很直观地看出，哪些操作是线程安全的，哪些操作是线程不安全的。 </p>
<p>这个图看懂后，下面的代码分析就简单了。</p>
<p>接下来，我们一步步按照流程来走代码分析，我们先来看看 wait 方法：</p>
<pre><code class="lang-java hljs"><span class="hljs-comment"><span class="hljs-comment">// 首先，这个方法是可被中断的，不可被中断的是另一个方法 awaitUninterruptibly()</span></span>
<span class="hljs-comment"><span class="hljs-comment">// 这个方法会阻塞，直到调用 signal 方法（指 signal() 和 signalAll()，下同），或被中断</span></span>
<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">final</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">await</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> InterruptedException </span></span>{
    <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Thread.interrupted())
        <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> InterruptedException();
    <span class="hljs-comment"><span class="hljs-comment">// 添加到 condition 的条件队列中</span></span>
    Node node = addConditionWaiter();
    <span class="hljs-comment"><span class="hljs-comment">// 释放锁，返回值是释放锁之前的 state 值</span></span>
    <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> savedState = fullyRelease(node);
    <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> interruptMode = <span class="hljs-number"><span class="hljs-number">0</span></span>;
    <span class="hljs-comment"><span class="hljs-comment">// 这里退出循环有两种情况，之后再仔细分析</span></span>
    <span class="hljs-comment"><span class="hljs-comment">// 1. isOnSyncQueue(node) 返回 true，即当前 node 已经转移到阻塞队列了</span></span>
    <span class="hljs-comment"><span class="hljs-comment">// 2. checkInterruptWhileWaiting(node) != 0 会到 break，然后退出循环，代表的是线程中断</span></span>
    <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (!isOnSyncQueue(node)) {
        LockSupport.park(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>);
        <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="hljs-number"><span class="hljs-number">0</span></span>)
            <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>;
    }
    <span class="hljs-comment"><span class="hljs-comment">// 被唤醒后，将进入阻塞队列，等待获取锁</span></span>
    <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)
        interruptMode = REINTERRUPT;
    <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (node.nextWaiter != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) <span class="hljs-comment"><span class="hljs-comment">// clean up if cancelled</span></span>
        unlinkCancelledWaiters();
    <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (interruptMode != <span class="hljs-number"><span class="hljs-number">0</span></span>)
        reportInterruptAfterWait(interruptMode);
}
</code></pre>
<p>其实，我大体上也把整个 await 过程说得十之八九了，下面我们分步把上面的几个点用源码说清楚。</p>
<span id="toc2"></span><h3 id="1.%20%E5%B0%86%E8%8A%82%E7%82%B9%E5%8A%A0%E5%85%A5%E5%88%B0%E6%9D%A1%E4%BB%B6%E9%98%9F%E5%88%97">1. 将节点加入到条件队列</h3>
<p>addConditionWaiter() 是将当前节点加入到条件队列，看图我们知道，这种条件队列内的操作是线程安全的。</p>
<pre><code class="lang-java hljs"><span class="hljs-comment"><span class="hljs-comment">// 将当前线程对应的节点入队，插入队尾</span></span>
<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> Node </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addConditionWaiter</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{
    Node t = lastWaiter;
    <span class="hljs-comment"><span class="hljs-comment">// 如果条件队列的最后一个节点取消了，将其清除出去</span></span>
    <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (t != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> &amp;&amp; t.waitStatus != Node.CONDITION) {
        <span class="hljs-comment"><span class="hljs-comment">// 这个方法会遍历整个条件队列，然后会将已取消的所有节点清除出队列</span></span>
        unlinkCancelledWaiters();
        t = lastWaiter;
    }
    Node node = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Node(Thread.currentThread(), Node.CONDITION);
    <span class="hljs-comment"><span class="hljs-comment">// 如果队列为空</span></span>
    <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (t == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>)
        firstWaiter = node;
    <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>
        t.nextWaiter = node;
    lastWaiter = node;
    <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> node;
}
</code></pre>
<p>在addWaiter 方法中，有一个 unlinkCancelledWaiters() 方法，该方法用于清除队列中已经取消等待的节点。</p>
<p>当 await 的时候如果发生了取消操作（这点之后会说），或者是在节点入队的时候，发现最后一个节点是被取消的，会调用一次这个方法。</p>
<pre><code class="lang-java hljs"><span class="hljs-comment"><span class="hljs-comment">// 等待队列是一个单向链表，遍历链表将已经取消等待的节点清除出去</span></span>
<span class="hljs-comment"><span class="hljs-comment">// 纯属链表操作，很好理解，看不懂多看几遍就可以了</span></span>
<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">unlinkCancelledWaiters</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{
    Node t = firstWaiter;
    Node trail = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>;
    <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (t != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) {
        Node next = t.nextWaiter;
        <span class="hljs-comment"><span class="hljs-comment">// 如果节点的状态不是 Node.CONDITION 的话，这个节点就是被取消的</span></span>
        <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (t.waitStatus != Node.CONDITION) {
            t.nextWaiter = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>;
            <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (trail == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>)
                firstWaiter = next;
            <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>
                trail.nextWaiter = next;
            <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (next == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>)
                lastWaiter = trail;
        }
        <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>
            trail = t;
        t = next;
    }
}
</code></pre>
<span id="toc3"></span><h3 id="2.%20%E5%AE%8C%E5%85%A8%E9%87%8A%E6%94%BE%E7%8B%AC%E5%8D%A0%E9%94%81">2. 完全释放独占锁</h3>
<p>回到 wait 方法，节点入队了以后，会调用 <code>int savedState = fullyRelease(node);</code> 方法释放锁，注意，这里是完全释放独占锁，因为 ReentrantLock 是可以重入的。</p>
<pre><code class="lang-java hljs"><span class="hljs-comment"><span class="hljs-comment">// 首先，我们要先观察到返回值 savedState 代表 release 之前的 state 值</span></span>
<span class="hljs-comment"><span class="hljs-comment">// 对于最简单的操作：先 lock.lock()，然后 condition1.await()。</span></span>
<span class="hljs-comment"><span class="hljs-comment">//         那么 state 经过这个方法由 1 变为 0，锁释放，此方法返回 1</span></span>
<span class="hljs-comment"><span class="hljs-comment">//         相应的，如果 lock 重入了 n 次，savedState == n</span></span>
<span class="hljs-comment"><span class="hljs-comment">// 如果这个方法失败，会将节点设置为"取消"状态，并抛出异常 IllegalMonitorStateException</span></span>
<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">final</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fullyRelease</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Node node)</span></span></span><span class="hljs-function"> </span></span>{
    <span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> failed = <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>;
    <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> {
        <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> savedState = getState();
        <span class="hljs-comment"><span class="hljs-comment">// 这里使用了当前的 state 作为 release 的参数，也就是完全释放掉锁，将 state 置为 0</span></span>
        <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (release(savedState)) {
            failed = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>;
            <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> savedState;
        } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> {
            <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> IllegalMonitorStateException();
        }
    } <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span> {
        <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (failed)
            node.waitStatus = Node.CANCELLED;
    }
}
</code></pre>
<span id="toc4"></span><h3 id="3.%20%E7%AD%89%E5%BE%85%E8%BF%9B%E5%85%A5%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97">3. 等待进入阻塞队列</h3>
<p>释放掉锁以后，接下来是这段，这边会自旋，如果发现自己还没到阻塞队列，那么挂起，等待被转移到阻塞队列。</p>
<pre><code class="lang-java hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> interruptMode = <span class="hljs-number"><span class="hljs-number">0</span></span>;
<span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (!isOnSyncQueue(node)) {
    <span class="hljs-comment"><span class="hljs-comment">// 线程挂起</span></span>
    LockSupport.park(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>);

    <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="hljs-number"><span class="hljs-number">0</span></span>)
        <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>;
}
</code></pre>
<p>isOnSyncQueue(Node node) 用于判断节点是否已经转移到阻塞队列了：</p>
<pre><code class="lang-java hljs"><span class="hljs-comment"><span class="hljs-comment">// 在节点入条件队列的时候，初始化时设置了 waitStatus = Node.CONDITION</span></span>
<span class="hljs-comment"><span class="hljs-comment">// 前面我提到，signal 的时候需要将节点从条件队列移到阻塞队列，</span></span>
<span class="hljs-comment"><span class="hljs-comment">// 这个方法就是判断 node 是否已经移动到阻塞队列了</span></span>
<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">final</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isOnSyncQueue</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Node node)</span></span></span><span class="hljs-function"> </span></span>{
    <span class="hljs-comment"><span class="hljs-comment">// 移动过去的时候，node 的 waitStatus 会置为 0，这个之后在说 signal 方法的时候会说到</span></span>
    <span class="hljs-comment"><span class="hljs-comment">// 如果 waitStatus 还是 Node.CONDITION，也就是 -2，那肯定就是还在条件队列中</span></span>
    <span class="hljs-comment"><span class="hljs-comment">// 如果 node 的前驱 prev 指向还是 null，说明肯定没有在 阻塞队列</span></span>
    <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (node.waitStatus == Node.CONDITION || node.prev == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>)
        <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>;
    <span class="hljs-comment"><span class="hljs-comment">// 如果 node 已经有后继节点 next 的时候，那肯定是在阻塞队列了</span></span>
    <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (node.next != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) 
        <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>;

    <span class="hljs-comment"><span class="hljs-comment">// 这个方法从阻塞队列的队尾开始从后往前遍历找，如果找到相等的，说明在阻塞队列，否则就是不在阻塞队列</span></span>

    <span class="hljs-comment"><span class="hljs-comment">// 可以通过判断 node.prev() != null 来推断出 node 在阻塞队列吗？答案是：不能。</span></span>
    <span class="hljs-comment"><span class="hljs-comment">// 这个可以看上篇 AQS 的入队方法，首先设置的是 node.prev 指向 tail，</span></span>
    <span class="hljs-comment"><span class="hljs-comment">// 然后是 CAS 操作将自己设置为新的 tail，可是这次的 CAS 是可能失败的。</span></span>

    <span class="hljs-comment"><span class="hljs-comment">// 调用这个方法的时候，往往我们需要的就在队尾的部分，所以一般都不需要完全遍历整个队列的</span></span>
    <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> findNodeFromTail(node);
}

<span class="hljs-comment"><span class="hljs-comment">// 从同步队列的队尾往前遍历，如果找到，返回 true</span></span>
<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findNodeFromTail</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Node node)</span></span></span><span class="hljs-function"> </span></span>{
    Node t = tail;
    <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (;;) {
        <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (t == node)
            <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>;
        <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (t == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>)
            <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>;
        t = t.prev;
    }
}
</code></pre>
<p>回到前面的循环，isOnSyncQueue(node) 返回 false 的话，那么进到 <code>LockSupport.park(this);</code> 这里线程挂起。</p>
<span id="toc5"></span><h3 id="4.%20signal%20%E5%94%A4%E9%86%92%E7%BA%BF%E7%A8%8B%EF%BC%8C%E8%BD%AC%E7%A7%BB%E5%88%B0%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97">4. signal 唤醒线程，转移到阻塞队列</h3>
<p>为了大家理解，这里我们先看唤醒操作，因为刚刚到 LockSupport.park(this); 把线程挂起了，等待唤醒。</p>
<p>唤醒操作通常由另一个线程来操作，就像生产者-消费者模式中，如果线程因为等待消费而挂起，那么当生产者生产了一个东西后，会调用 signal 唤醒正在等待的线程来消费。</p>
<pre><code class="lang-java hljs"><span class="hljs-comment"><span class="hljs-comment">// 唤醒等待了最久的线程</span></span>
<span class="hljs-comment"><span class="hljs-comment">// 其实就是，将这个线程对应的 node 从条件队列转移到阻塞队列</span></span>
<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">final</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">signal</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{
    <span class="hljs-comment"><span class="hljs-comment">// 调用 signal 方法的线程必须持有当前的独占锁</span></span>
    <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!isHeldExclusively())
        <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> IllegalMonitorStateException();
    Node first = firstWaiter;
    <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (first != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>)
        doSignal(first);
}

<span class="hljs-comment"><span class="hljs-comment">// 从条件队列队头往后遍历，找出第一个需要转移的 node</span></span>
<span class="hljs-comment"><span class="hljs-comment">// 因为前面我们说过，有些线程会取消排队，但是还在队列中</span></span>
<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doSignal</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Node first)</span></span></span><span class="hljs-function"> </span></span>{
    <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> {
          <span class="hljs-comment"><span class="hljs-comment">// 将 firstWaiter 指向 first 节点后面的第一个</span></span>
        <span class="hljs-comment"><span class="hljs-comment">// 如果将队头移除后，后面没有节点在等待了，那么需要将 lastWaiter 置为 null</span></span>
        <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( (firstWaiter = first.nextWaiter) == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>)
            lastWaiter = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>;
        <span class="hljs-comment"><span class="hljs-comment">// 因为 first 马上要被移到阻塞队列了，和条件队列的链接关系在这里断掉</span></span>
        first.nextWaiter = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>;
    } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (!transferForSignal(first) &amp;&amp;
             (first = firstWaiter) != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>);
      <span class="hljs-comment"><span class="hljs-comment">// 这里 while 循环，如果 first 转移不成功，那么选择 first 后面的第一个节点进行转移，依此类推</span></span>
}

<span class="hljs-comment"><span class="hljs-comment">// 将节点从条件队列转移到阻塞队列</span></span>
<span class="hljs-comment"><span class="hljs-comment">// true 代表成功转移</span></span>
<span class="hljs-comment"><span class="hljs-comment">// false 代表在 signal 之前，节点已经取消了</span></span>
<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">final</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">transferForSignal</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Node node)</span></span></span><span class="hljs-function"> </span></span>{

    <span class="hljs-comment"><span class="hljs-comment">// CAS 如果失败，说明此 node 的 waitStatus 已不是 Node.CONDITION，说明节点已经取消，</span></span>
    <span class="hljs-comment"><span class="hljs-comment">// 既然已经取消，也就不需要转移了，方法返回，转移后面一个节点</span></span>
    <span class="hljs-comment"><span class="hljs-comment">// 否则，将 waitStatus 置为 0</span></span>
    <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!compareAndSetWaitStatus(node, Node.CONDITION, <span class="hljs-number"><span class="hljs-number">0</span></span>))
        <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>;

    <span class="hljs-comment"><span class="hljs-comment">// enq(node): 自旋进入阻塞队列的队尾</span></span>
    <span class="hljs-comment"><span class="hljs-comment">// 注意，这里的返回值 p 是 node 在阻塞队列的前驱节点</span></span>
    Node p = enq(node);
    <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ws = p.waitStatus;
    <span class="hljs-comment"><span class="hljs-comment">// ws &gt; 0 说明 node 在阻塞队列中的前驱节点取消了等待锁，直接唤醒 node 对应的线程。唤醒之后会怎么样，后面再解释</span></span>
    <span class="hljs-comment"><span class="hljs-comment">// 如果 ws &lt;= 0, 那么 compareAndSetWaitStatus 将会被调用，上篇介绍的时候说过，节点入队后，需要把前驱节点的状态设为 Node.SIGNAL(-1)</span></span>
    <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ws &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> || !compareAndSetWaitStatus(p, ws, Node.SIGNAL))
        <span class="hljs-comment"><span class="hljs-comment">// 如果前驱节点取消或者 CAS 失败，会进到这里唤醒线程，之后的操作看下一节</span></span>
        LockSupport.unpark(node.thread);
    <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>;
}
</code></pre>
<p>正常情况下，<code>ws &gt; 0 || !compareAndSetWaitStatus(p, ws, Node.SIGNAL)</code> 这句中，ws &lt;= 0，而且 compareAndSetWaitStatus(p, ws, Node.SIGNAL) 会返回 true，所以一般也不会进去 if 语句块中唤醒 node 对应的线程。然后这个方法返回 true，也就意味着 signal 方法结束了，节点进入了阻塞队列。</p>
<p>假设发生了阻塞队列中的前驱节点取消等待，或者 CAS 失败，只要唤醒线程，让其进到下一步即可。</p>
<span id="toc6"></span><h3 id="5.%20%E5%94%A4%E9%86%92%E5%90%8E%E6%A3%80%E6%9F%A5%E4%B8%AD%E6%96%AD%E7%8A%B6%E6%80%81">5. 唤醒后检查中断状态</h3>
<p>上一步 signal 之后，我们的线程由条件队列转移到了阻塞队列，之后就准备获取锁了。只要重新获取到锁了以后，继续往下执行。</p>
<p>等线程从挂起中恢复过来，继续往下看</p>
<pre><code class="lang-java hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> interruptMode = <span class="hljs-number"><span class="hljs-number">0</span></span>;
<span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (!isOnSyncQueue(node)) {
    <span class="hljs-comment"><span class="hljs-comment">// 线程挂起</span></span>
    LockSupport.park(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>);

    <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="hljs-number"><span class="hljs-number">0</span></span>)
        <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>;
}
</code></pre>
<p>先解释下 interruptMode。interruptMode 可以取值为 REINTERRUPT（1），THROW_IE（-1），0</p>
<ul>
<li>REINTERRUPT： 代表 await 返回的时候，需要重新设置中断状态</li>
<li>THROW_IE： 代表 await 返回的时候，需要抛出 InterruptedException 异常</li>
<li>0 ：说明在 await 期间，没有发生中断</li>
</ul>
<p>有以下三种情况会让 LockSupport.park(this); 这句返回继续往下执行：</p>
<ol>
<li>常规路劲。signal -&gt; 转移节点到阻塞队列 -&gt; 获取了锁（unpark）</li>
<li>线程中断。在 park 的时候，另外一个线程对这个线程进行了中断</li>
<li>signal 的时候我们说过，转移以后的前驱节点取消了，或者对前驱节点的CAS操作失败了</li>
<li>假唤醒。这个也是存在的，和 Object.wait() 类似，都有这个问题</li>
</ol>
<p>线程唤醒后第一步是调用 checkInterruptWhileWaiting(node) 这个方法，此方法用于判断是否在线程挂起期间发生了中断，如果发生了中断，是 signal 调用之前中断的，还是 signal 之后发生的中断。</p>
<pre><code class="lang-java hljs"><span class="hljs-comment"><span class="hljs-comment">// 1. 如果在 signal 之前已经中断，返回 THROW_IE</span></span>
<span class="hljs-comment"><span class="hljs-comment">// 2. 如果是 signal 之后中断，返回 REINTERRUPT</span></span>
<span class="hljs-comment"><span class="hljs-comment">// 3. 没有发生中断，返回 0</span></span>
<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">checkInterruptWhileWaiting</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Node node)</span></span></span><span class="hljs-function"> </span></span>{
    <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Thread.interrupted() ?
        (transferAfterCancelledWait(node) ? THROW_IE : REINTERRUPT) :
        <span class="hljs-number"><span class="hljs-number">0</span></span>;
}
</code></pre>
<blockquote>
<p>Thread.interrupted()：如果当前线程已经处于中断状态，那么该方法返回 true，同时将中断状态重置为 false，所以，才有后续的 <code>重新中断（REINTERRUPT）</code> 的使用。</p>
</blockquote>
<p>看看怎么判断是 signal 之前还是之后发生的中断：</p>
<pre><code class="lang-java hljs"><span class="hljs-comment"><span class="hljs-comment">// 只有线程处于中断状态，才会调用此方法</span></span>
<span class="hljs-comment"><span class="hljs-comment">// 如果需要的话，将这个已经取消等待的节点转移到阻塞队列</span></span>
<span class="hljs-comment"><span class="hljs-comment">// 返回 true：如果此线程在 signal 之前被取消，</span></span>
<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">final</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">transferAfterCancelledWait</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Node node)</span></span></span><span class="hljs-function"> </span></span>{
    <span class="hljs-comment"><span class="hljs-comment">// 用 CAS 将节点状态设置为 0 </span></span>
    <span class="hljs-comment"><span class="hljs-comment">// 如果这步 CAS 成功，说明是 signal 方法之前发生的中断，因为如果 signal 先发生的话，signal 中会将 waitStatus 设置为 0</span></span>
    <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (compareAndSetWaitStatus(node, Node.CONDITION, <span class="hljs-number"><span class="hljs-number">0</span></span>)) {
        <span class="hljs-comment"><span class="hljs-comment">// 将节点放入阻塞队列</span></span>
        <span class="hljs-comment"><span class="hljs-comment">// 这里我们看到，即使中断了，依然会转移到阻塞队列</span></span>
        enq(node);
        <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>;
    }

    <span class="hljs-comment"><span class="hljs-comment">// 到这里是因为 CAS 失败，肯定是因为 signal 方法已经将 waitStatus 设置为了 0</span></span>
    <span class="hljs-comment"><span class="hljs-comment">// signal 方法会将节点转移到阻塞队列，但是可能还没完成，这边自旋等待其完成</span></span>
    <span class="hljs-comment"><span class="hljs-comment">// 当然，这种事情还是比较少的吧：signal 调用之后，没完成转移之前，发生了中断</span></span>
    <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (!isOnSyncQueue(node))
        Thread.yield();
    <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>;
}
</code></pre>
<blockquote>
<p>这里再说一遍，即使发生了中断，节点依然会转移到阻塞队列。</p>
</blockquote>
<p>到这里，大家应该都知道这个 while 循环怎么退出了吧。要么中断，要么转移成功。</p>
<span id="toc7"></span><h3 id="6.%20%E8%8E%B7%E5%8F%96%E7%8B%AC%E5%8D%A0%E9%94%81">6. 获取独占锁</h3>
<p>while 循环出来以后，下面是这段代码：</p>
<pre><code class="lang-java hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)
    interruptMode = REINTERRUPT;
</code></pre>
<p>由于 while 出来后，我们确定节点已经进入了阻塞队列，准备获取锁。</p>
<p>这里的 acquireQueued(node, savedState) 的第一个参数 node 之前已经经过 enq(node) 进入了队列，参数 savedState 是之前释放锁前的 state，这个方法返回的时候，代表当前线程获取了锁，而且 state == savedState了。</p>
<p>注意，前面我们说过，不管有没有发生中断，都会进入到阻塞队列，而 acquireQueued(node, savedState) 的返回值就是代表线程是否被中断。如果返回 true，说明被中断了，而且 interruptMode != THROW_IE，说明在 signal 之前就发生中断了，这里将 interruptMode 设置为 REINTERRUPT，用于待会重新中断。</p>
<p>继续往下：</p>
<pre><code class="lang-java hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (node.nextWaiter != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) <span class="hljs-comment"><span class="hljs-comment">// clean up if cancelled</span></span>
    unlinkCancelledWaiters();
<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (interruptMode != <span class="hljs-number"><span class="hljs-number">0</span></span>)
    reportInterruptAfterWait(interruptMode);
</code></pre>
<p>本着一丝不苟的精神，这边说说 <code>node.nextWaiter != null</code> 怎么满足。我前面也说了 signal 的时候会将节点转移到阻塞队列，有一步是 node.nextWaiter = null，将断开节点和条件队列的联系。</p>
<p>可是，<code>在判断发生中断的情况下，是 signal 之前还是之后发生的？</code> 这部分的时候，我也介绍了，如果 signal 之前就中断了，也需要将节点进行转移到阻塞队列，这部分转移的时候，是没有设置 node.nextWaiter = null 的。</p>
<p>之前我们说过，如果有节点取消，也会调用 unlinkCancelledWaiters 这个方法，就是这里了。</p>
<span id="toc8"></span><h3 id="7.%20%E5%A4%84%E7%90%86%E4%B8%AD%E6%96%AD%E7%8A%B6%E6%80%81">7. 处理中断状态</h3>
<p>到这里，我们终于可以好好说下这个 interruptMode 干嘛用了。</p>
<ul>
<li>0：什么都不做。</li>
<li>THROW_IE：await 方法抛出 InterruptedException 异常</li>
<li>REINTERRUPT：重新中断当前线程</li>
</ul>
<pre><code class="lang-java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">reportInterruptAfterWait</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> interruptMode)</span></span></span><span class="hljs-function">
    </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> InterruptedException </span></span>{
    <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (interruptMode == THROW_IE)
        <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> InterruptedException();
    <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (interruptMode == REINTERRUPT)
        selfInterrupt();
}
</code></pre>
<blockquote>
<p>为什么这么处理？这部分的知识在本文的最后一节</p>
</blockquote>
<span id="toc9"></span><h3 id="*%20%E5%B8%A6%E8%B6%85%E6%97%B6%E6%9C%BA%E5%88%B6%E7%9A%84%20await">* 带超时机制的 await</h3>
<p>经过前面的 7 步，整个 ConditionObject 类基本上都分析完了，接下来简单分析下带超时机制的 await 方法。</p>
<pre><code class="lang-java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">final</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">long</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">awaitNanos</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> nanosTimeout)</span></span></span><span class="hljs-function"> 
                  </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> InterruptedException
</span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">final</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">awaitUntil</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Date deadline)</span></span></span><span class="hljs-function">
                </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> InterruptedException
</span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">final</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">await</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> time, TimeUnit unit)</span></span></span><span class="hljs-function">
                </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> InterruptedException
</span></span></code></pre>
<p>这三个方法都差不多，我们就挑一个出来看看吧：</p>
<pre><code class="lang-java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">final</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">await</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> time, TimeUnit unit)</span></span></span><span class="hljs-function">
        </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> InterruptedException </span></span>{
    <span class="hljs-comment"><span class="hljs-comment">// 等待这么多纳秒</span></span>
    <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> nanosTimeout = unit.toNanos(time);
    <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Thread.interrupted())
        <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> InterruptedException();
    Node node = addConditionWaiter();
    <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> savedState = fullyRelease(node);
    <span class="hljs-comment"><span class="hljs-comment">// 当前时间 + 等待时长 = 过期时间</span></span>
    <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> deadline = System.nanoTime() + nanosTimeout;
    <span class="hljs-comment"><span class="hljs-comment">// 用于返回 await 是否超时</span></span>
    <span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> timedout = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>;
    <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> interruptMode = <span class="hljs-number"><span class="hljs-number">0</span></span>;
    <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (!isOnSyncQueue(node)) {
        <span class="hljs-comment"><span class="hljs-comment">// 时间到啦</span></span>
        <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (nanosTimeout &lt;= <span class="hljs-number"><span class="hljs-number">0L</span></span>) {
            <span class="hljs-comment"><span class="hljs-comment">// 这里因为要 break 取消等待了。取消等待的话一定要调用 transferAfterCancelledWait(node) 这个方法</span></span>
            <span class="hljs-comment"><span class="hljs-comment">// 如果这个方法返回 true，在这个方法内，将节点转移到阻塞队列成功</span></span>
            <span class="hljs-comment"><span class="hljs-comment">// 返回 false 的话，说明 signal 已经发生，signal 方法将节点转移了。也就是说没有超时嘛</span></span>
            timedout = transferAfterCancelledWait(node);
            <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>;
        }
        <span class="hljs-comment"><span class="hljs-comment">// spinForTimeoutThreshold 的值是 1000 纳秒，也就是 1 毫秒</span></span>
        <span class="hljs-comment"><span class="hljs-comment">// 也就是说，如果不到 1 毫秒了，那就不要选择 parkNanos 了，自旋的性能反而更好</span></span>
        <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (nanosTimeout &gt;= spinForTimeoutThreshold)
            LockSupport.parkNanos(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, nanosTimeout);
        <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="hljs-number"><span class="hljs-number">0</span></span>)
            <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>;
        <span class="hljs-comment"><span class="hljs-comment">// 得到剩余时间</span></span>
        nanosTimeout = deadline - System.nanoTime();
    }
    <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)
        interruptMode = REINTERRUPT;
    <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (node.nextWaiter != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>)
        unlinkCancelledWaiters();
    <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (interruptMode != <span class="hljs-number"><span class="hljs-number">0</span></span>)
        reportInterruptAfterWait(interruptMode);
    <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> !timedout;
}
</code></pre>
<p>超时的思路还是很简单的，不带超时参数的 await 是 park，然后等待别人唤醒。而现在就是调用 parkNanos 方法来休眠指定的时间，醒来后判断是否 signal 调用了，调用了就是没有超时，否则就是超时了。超时的话，自己来进行转移到阻塞队列，然后抢锁。</p>
<span id="toc10"></span><h3 id="*%20%E4%B8%8D%E6%8A%9B%E5%87%BA%20InterruptedException%20%E7%9A%84%20await">* 不抛出 InterruptedException 的 await</h3>
<p>关于 Condition 最后一小节了。</p>
<pre><code class="lang-java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">final</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">awaitUninterruptibly</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{
    Node node = addConditionWaiter();
    <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> savedState = fullyRelease(node);
    <span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> interrupted = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>;
    <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (!isOnSyncQueue(node)) {
        LockSupport.park(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>);
        <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Thread.interrupted())
            interrupted = <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>;
    }
    <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (acquireQueued(node, savedState) || interrupted)
        selfInterrupt();
}
</code></pre>
<p>很简单，我就不废话了。</p>
<span id="toc11"></span><h2 id="AbstractQueuedSynchronizer%20%E7%8B%AC%E5%8D%A0%E9%94%81%E7%9A%84%E5%8F%96%E6%B6%88%E6%8E%92%E9%98%9F">AbstractQueuedSynchronizer 独占锁的取消排队</h2>
<p>这篇文章说的是 AbstractQueuedSynchronizer，只不过好像 Condition 说太多了，赶紧把思路拉回来。</p>
<p>接下来，我想说说怎么取消对锁的竞争？</p>
<p>上篇文章提到过，最重要的方法是这个，我们要在这里面找答案：</p>
<pre><code class="lang-java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">final</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">acquireQueued</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Node node, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> arg)</span></span></span><span class="hljs-function"> </span></span>{
    <span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> failed = <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>;
    <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> {
        <span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> interrupted = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>;
        <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (;;) {
            <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Node p = node.predecessor();
            <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (p == head &amp;&amp; tryAcquire(arg)) {
                setHead(node);
                p.next = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; <span class="hljs-comment"><span class="hljs-comment">// help GC</span></span>
                failed = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>;
                <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> interrupted;
            }
            <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;
                parkAndCheckInterrupt())
                interrupted = <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>;
        }
    } <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span> {
        <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (failed)
            cancelAcquire(node);
    }
}
</code></pre>
<p>首先，到这个方法的时候，节点一定是入队成功的。</p>
<p>我把 parkAndCheckInterrupt() 代码贴过来：</p>
<pre><code class="lang-java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">final</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parkAndCheckInterrupt</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{
    LockSupport.park(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>);
    <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Thread.interrupted();
}
</code></pre>
<p>这两段代码联系起来看，是不是就清楚了。</p>
<p>如果我们要取消一个线程的排队，我们需要在另外一个线程中对其进行中断。比如某线程调用 lock() 老久不返回，我想中断它。一旦对其进行中断，此线程会从 <code>LockSupport.park(this);</code> 中唤醒，然后 <code>Thread.interrupted();</code> 返回 true。</p>
<p>我们发现一个问题，即使是中断唤醒了这个线程，也就只是设置了 <code>interrupted = true</code> 然后继续下一次循环。而且，由于 <code>Thread.interrupted();</code>  会清除中断状态，第二次进 parkAndCheckInterrupt 的时候，返回会是 false。</p>
<p>所以，我们要看到，在这个方法中，interrupted 只是用来记录是否发生了中断，然后用于方法返回值，其他没有做任何相关事情。</p>
<p>所以，我们看外层方法怎么处理 acquireQueued 返回 false 的情况。</p>
<pre><code class="lang-java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">final</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">acquire</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> arg)</span></span></span><span class="hljs-function"> </span></span>{
    <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!tryAcquire(arg) &amp;&amp;
        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))
        selfInterrupt();
}
<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">selfInterrupt</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{
    Thread.currentThread().interrupt();
}
</code></pre>
<p>所以说，lock() 方法处理中断的方法就是，你中断归中断，我抢锁还是照样抢锁，几乎没关系，只是我抢到锁了以后，设置线程的中断状态而已，也不抛出任何异常出来。调用者获取锁后，可以去检查是否发生过中断，也可以不理会。</p>
<hr>
<p>来条分割线。有没有被骗的感觉，我说了一大堆，可是和取消没有任何关系啊。</p>
<p>我们来看 ReentrantLock 的另一个 lock 方法：</p>
<pre><code class="lang-java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">lockInterruptibly</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> InterruptedException </span></span>{
    sync.acquireInterruptibly(<span class="hljs-number"><span class="hljs-number">1</span></span>);
}
</code></pre>
<p>方法上多了个 <code>throws InterruptedException</code> ，经过前面那么多知识的铺垫，这里我就不再啰里啰嗦了。</p>
<pre><code class="lang-java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">final</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">acquireInterruptibly</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> arg)</span></span></span><span class="hljs-function">
        </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> InterruptedException </span></span>{
    <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Thread.interrupted())
        <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> InterruptedException();
    <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!tryAcquire(arg))
        doAcquireInterruptibly(arg);
}
</code></pre>
<p>继续往里：</p>
<pre><code class="lang-java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doAcquireInterruptibly</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> arg)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> InterruptedException </span></span>{
    <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Node node = addWaiter(Node.EXCLUSIVE);
    <span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> failed = <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>;
    <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> {
        <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (;;) {
            <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Node p = node.predecessor();
            <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (p == head &amp;&amp; tryAcquire(arg)) {
                setHead(node);
                p.next = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; <span class="hljs-comment"><span class="hljs-comment">// help GC</span></span>
                failed = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>;
                <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>;
            }
            <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;
                parkAndCheckInterrupt())
                <span class="hljs-comment"><span class="hljs-comment">// 就是这里了，一旦异常，马上结束这个方法，抛出异常。</span></span>
                <span class="hljs-comment"><span class="hljs-comment">// 这里不再只是标记这个方法的返回值代表中断状态</span></span>
                <span class="hljs-comment"><span class="hljs-comment">// 而是直接抛出异常，而且外层也不捕获，一直往外抛到 lockInterruptibly</span></span>
                <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> InterruptedException();
        }
    } <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span> {
        <span class="hljs-comment"><span class="hljs-comment">// 如果通过 InterruptedException 异常出去，那么 failed 就是 true 了</span></span>
        <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (failed)
            cancelAcquire(node);
    }
}
</code></pre>
<p>既然到这里了，顺便说说 cancelAcquire 这个方法吧：</p>
<pre><code class="lang-java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cancelAcquire</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Node node)</span></span></span><span class="hljs-function"> </span></span>{
    <span class="hljs-comment"><span class="hljs-comment">// Ignore if node doesn't exist</span></span>
    <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (node == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>)
        <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>;
    node.thread = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>;
    <span class="hljs-comment"><span class="hljs-comment">// Skip cancelled predecessors</span></span>
    Node pred = node.prev;
    <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (pred.waitStatus &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>)
        node.prev = pred = pred.prev;
    <span class="hljs-comment"><span class="hljs-comment">// predNext is the apparent node to unsplice. CASes below will</span></span>
    <span class="hljs-comment"><span class="hljs-comment">// fail if not, in which case, we lost race vs another cancel</span></span>
    <span class="hljs-comment"><span class="hljs-comment">// or signal, so no further action is necessary.</span></span>
    Node predNext = pred.next;
    <span class="hljs-comment"><span class="hljs-comment">// Can use unconditional write instead of CAS here.</span></span>
    <span class="hljs-comment"><span class="hljs-comment">// After this atomic step, other Nodes can skip past us.</span></span>
    <span class="hljs-comment"><span class="hljs-comment">// Before, we are free of interference from other threads.</span></span>
    node.waitStatus = Node.CANCELLED;
    <span class="hljs-comment"><span class="hljs-comment">// If we are the tail, remove ourselves.</span></span>
    <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (node == tail &amp;&amp; compareAndSetTail(node, pred)) {
        compareAndSetNext(pred, predNext, <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>);
    } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> {
        <span class="hljs-comment"><span class="hljs-comment">// If successor needs signal, try to set pred's next-link</span></span>
        <span class="hljs-comment"><span class="hljs-comment">// so it will get one. Otherwise wake it up to propagate.</span></span>
        <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ws;
        <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (pred != head &amp;&amp;
            ((ws = pred.waitStatus) == Node.SIGNAL ||
             (ws &lt;= <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; compareAndSetWaitStatus(pred, ws, Node.SIGNAL))) &amp;&amp;
            pred.thread != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) {
            Node next = node.next;
            <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (next != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> &amp;&amp; next.waitStatus &lt;= <span class="hljs-number"><span class="hljs-number">0</span></span>)
                compareAndSetNext(pred, predNext, next);
        } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> {
            unparkSuccessor(node);
        }
        node.next = node; <span class="hljs-comment"><span class="hljs-comment">// help GC</span></span>
    }
}
</code></pre>
<p>到这里，我想我应该把取消排队这件事说清楚了吧。</p>
<span id="toc12"></span><h2 id="%E5%86%8D%E8%AF%B4%20java%20%E7%BA%BF%E7%A8%8B%E4%B8%AD%E6%96%AD%E5%92%8C%20InterruptedException%20%E5%BC%82%E5%B8%B8">再说 java 线程中断和 InterruptedException 异常</h2>
<p>在之前的文章中，我们接触了大量的中断，这边算是个总结吧。如果你完全熟悉中断了，没有必要再看这节，本节为新手而写。</p>
<span id="toc13"></span><h3 id="%E7%BA%BF%E7%A8%8B%E4%B8%AD%E6%96%AD">线程中断</h3>
<p>首先，我们要明白，中断不是类似 linux 里面的命令 kill -9 pid，不是说我们中断某个线程，这个线程就停止运行了。中断代表线程状态，每个线程都关联了一个中断状态，是一个 true 或 false 的 boolean 值，初始值为 false。</p>
<p>关于中断状态，我们需要重点关注以下几个方法：</p>
<pre><code class="lang-java hljs"><span class="hljs-comment"><span class="hljs-comment">// Thread 类中的实例方法，持有线程实例引用即可检测线程中断状态</span></span>
<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isInterrupted</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{}

<span class="hljs-comment"><span class="hljs-comment">// Thread 中的静态方法，检测调用这个方法的线程是否已经中断</span></span>
<span class="hljs-comment"><span class="hljs-comment">// 注意：这个方法返回中断状态的同时，会将此线程的中断状态重置为 false</span></span>
<span class="hljs-comment"><span class="hljs-comment">// 所以，如果我们连续调用两次这个方法的话，第二次的返回值肯定就是 false 了</span></span>
<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">interrupted</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{}

<span class="hljs-comment"><span class="hljs-comment">// Thread 类中的实例方法，用于设置一个线程的中断状态为 true</span></span>
<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">interrupt</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{}
</code></pre>
<p>我们说中断一个线程，其实就是设置了线程的 interrupted status 为 true，至于说被中断的线程怎么处理这个状态，那是那个线程自己的事。如以下代码：</p>
<pre><code class="lang-java hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (!Thread.interrupted()) {
   doWork();
   System.out.println(<span class="hljs-string"><span class="hljs-string">"我做完一件事了，准备做下一件，如果没有其他线程中断我的话"</span></span>);
}
</code></pre>
<p>当然，中断除了是线程状态外，还有其他含义，否则也不需要专门搞一个这个概念出来了。</p>
<p>如果线程处于以下三种情况，那么当线程被中断的时候，能自动感知到：</p>
<ol>
<li><p>来自 Object 类的 wait()、wait(long)、wait(long, int)，</p>
<p>来自 Thread 类的 join()、join(long)、join(long, int)、sleep(long)、sleep(long, int)</p>
<blockquote>
<p>这几个方法的相同之处是，方法上都有: throws InterruptedException </p>
<p>如果线程阻塞在这些方法上（我们知道，这些方法会让当前线程阻塞），这个时候如果其他线程对这个线程进行了中断，那么这个线程会从这些方法中立即返回，抛出 InterruptedException 异常，同时重置中断状态为 false。</p>
</blockquote>
</li>
<li><p>实现了 InterruptibleChannel 接口的类中的一些 I/O 阻塞操作，如 DatagramChannel 中的 connect 方法和 receive 方法等</p>
<blockquote>
<p>如果线程阻塞在这里，中断线程会导致这些方法抛出 ClosedByInterruptException 并重置中断状态。</p>
</blockquote>
</li>
<li><p>Selector 中的 select 方法，这个有机会我们在讲 NIO 的时候说</p>
<blockquote>
<p>一旦中断，方法立即返回</p>
</blockquote>
</li>
</ol>
<p>对于以上 3 种情况是最特殊的，因为他们能自动感知到中断（这里说自动，当然也是基于底层实现），<strong>并且在做出相应的操作后都会重置中断状态为 false</strong>。</p>
<p>那是不是只有以上 3 种方法能自动感知到中断呢？不是的，如果线程阻塞在 LockSupport.park(Object obj) 方法，也叫挂起，这个时候的中断也会导致线程唤醒，但是唤醒后不会重置中断状态，所以唤醒后去检测中断状态将是 true。</p>
<span id="toc14"></span><h3 id="InterruptedException%20%E6%A6%82%E8%BF%B0">InterruptedException 概述</h3>
<p>它是一个特殊的异常，不是说 JVM 对其有特殊的处理，而是它的使用场景比较特殊。通常，我们可以看到，像 Object 中的 wait() 方法，ReentrantLock 中的 lockInterruptibly() 方法，Thread 中的 sleep() 方法等等，这些方法都带有 <code>throws InterruptedException</code>，我们通常称这些方法为阻塞方法（blocking method）。</p>
<p>阻塞方法一个很明显的特征是，它们需要花费比较长的时间（不是绝对的，只是说明时间不可控），还有它们的方法结束返回往往依赖于外部条件，如 wait 方法依赖于其他线程的 notify，lock 方法依赖于其他线程的 unlock等等。</p>
<p>当我们看到方法上带有 <code>throws InterruptedException</code> 时，我们就要知道，这个方法应该是阻塞方法，我们如果希望它能早点返回的话，我们往往可以通过中断来实现。 </p>
<p>除了几个特殊类（如 Object，Thread等）外，感知中断并提前返回是通过轮询中断状态来实现的。我们自己需要写可中断的方法的时候，就是通过在合适的时机（通常在循环的开始处）去判断线程的中断状态，然后做相应的操作（通常是方法直接返回或者抛出异常）。当然，我们也要看到，如果我们一次循环花的时间比较长的话，那么就需要比较长的时间才能注意到线程中断了。</p>
<span id="toc15"></span><h3 id="%E5%A4%84%E7%90%86%E4%B8%AD%E6%96%AD">处理中断</h3>
<p>一旦中断发生，我们接收到了这个信息，然后怎么去处理中断呢？本小节将简单分析这个问题。</p>
<p>我们经常会这么写代码：</p>
<pre><code class="lang-java hljs"><span class="hljs-keyword"><span class="hljs-keyword">try</span></span> {
    Thread.sleep(<span class="hljs-number"><span class="hljs-number">10000</span></span>);
} <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (InterruptedException e) {
    <span class="hljs-comment"><span class="hljs-comment">// ignore</span></span>
}
<span class="hljs-comment"><span class="hljs-comment">// go on</span></span>
</code></pre>
<p>当 sleep 结束继续往下执行的时候，我们往往都不知道这块代码是真的 sleep 了 10 秒，还是只休眠了 1 秒就被中断了。这个代码的问题在于，我们将这个异常信息吞掉了。（对于 sleep 方法，我相信大部分情况下，我们都不在意是否是中断了，这里是举例）</p>
<p>AQS 的做法很值得我们借鉴，我们知道 ReentrantLock 有两种 lock 方法：</p>
<pre><code class="lang-java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">lock</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{
    sync.lock();
}

<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">lockInterruptibly</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> InterruptedException </span></span>{
    sync.acquireInterruptibly(<span class="hljs-number"><span class="hljs-number">1</span></span>);
}
</code></pre>
<p>前面我们提到过，lock() 方法不响应中断。如果 thread1 调用了 lock() 方法，过了很久还没抢到锁，这个时候 thread2 对其进行了中断，thread1 是不响应这个请求的，它会继续抢锁，当然它不会把“被中断”这个信息扔掉。我们可以看以下代码：</p>
<pre><code class="lang-java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">final</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">acquire</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> arg)</span></span></span><span class="hljs-function"> </span></span>{
    <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!tryAcquire(arg) &amp;&amp;
        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))
        <span class="hljs-comment"><span class="hljs-comment">// 我们看到，这里也没做任何特殊处理，就是记录下来中断状态。</span></span>
        <span class="hljs-comment"><span class="hljs-comment">// 这样，如果外层方法需要去检测的时候，至少我们没有把这个信息丢了</span></span>
        selfInterrupt();<span class="hljs-comment"><span class="hljs-comment">// Thread.currentThread().interrupt();</span></span>
}
</code></pre>
<p>而对于 lockInterruptibly() 方法，因为其方法上面有 <code>throws InterruptedException</code> ，这个信号告诉我们，如果我们要取消线程抢锁，直接中断这个线程即可，它会立即返回，抛出 InterruptedException 异常。</p>
<p>在并发包中，有非常多的这种处理中断的例子，提供两个方法，分别为响应中断和不响应中断，对于不响应中断的方法，记录中断而不是丢失这个信息。如 Condition 中的两个方法就是这样的：</p>
<pre><code class="lang-java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">await</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> InterruptedException</span></span>;
<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">awaitUninterruptibly</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>;
</code></pre>
<blockquote>
<p>通常，如果方法会抛出 InterruptedException 异常，往往方法体的第一句就是：</p>
<pre><code class="lang-java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">final</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">await</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> InterruptedException </span></span>{
    <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Thread.interrupted())
        <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> InterruptedException();
     ...... 
}
</code></pre>
</blockquote>
<p>熟练使用中断，对于我们写出优雅的代码是有帮助的，也有助于我们分析别人的源码。</p>
<blockquote>
<p>参考：<a href="https://www.ibm.com/developerworks/library/j-jtp05236/index.html">https://www.ibm.com/developerworks/library/j-jtp05236/index.html</a></p>
<p>翻译：<a href="https://www.ibm.com/developerworks/cn/java/j-jtp05236.html">https://www.ibm.com/developerworks/cn/java/j-jtp05236.html</a></p>
</blockquote>
<span id="toc16"></span><h2 id="%E6%80%BB%E7%BB%93">总结</h2>
<p>这部分就留着读者吧，希望读者看完有所收获。</p>


            <div id="comment">
                

<h4 data-toc-skip="" style="color: #5694ca; margin-bottom: 1.5em; border-bottom: 1px solid #ccc; line-height: 2em;">评论区</h4>

<div id="vcomments" class="comments-block"><div class="media"><div class="media-left"><img src="./一行一行源码分析清楚 AbstractQueuedSynchronizer (二)_files/7.png" alt="" class="media-object img-circle" style="width: 50px; height: 50px;"></div> <div class="media-body"><h5 data-toc-skip="" class="media-heading"><img src="./一行一行源码分析清楚 AbstractQueuedSynchronizer (二)_files/7.png" alt="" class="img-circle" style="display: none; width: 30px; height: 30px;">
                孙同学
                <span class="pull-right">2018-03-25 10:12</span></h5> <p><p>大神你好！</p>
<p>我有一个问题，在：“6获取独占锁”这一节。</p>
<p>文中说：“注意，前面我们说过，不管有没有发生中断，都会进入到阻塞队列，而 acquireQueued(node, savedState) 的返回值就是代表线程是否被中断。如果返回 true，说明被中断了，而且 interruptMode != THROW_IE，说明在 signal 之前就发生中断了，这里将 interruptMode 设置为 REINTERRUPT，用于待会重新中断。”</p>
<p>这里，“而且 interruptMode != THROW_IE，说明在 signal 之前就发生中断了”我不太理解。</p>
<p>如果是signal前发生中断的话，不是会返回THROW_IE吗？</p>
</p> <p><a href="javascript:;" class="reply">回复</a> <!----></p> <div class="add-comment nested-comment" style="display: none;"><form class="form-horizontal"><div class="form-group"><div class="col-md-4 col-sm-12 col-xs-12"><label class="control-label visible-xs">Name <span class="text-theme">*</span></label> <input type="text" placeholder="Name *" class="form-control"></div> <div class="col-md-4 col-sm-12 col-xs-12"><label class="control-label visible-xs">Email <span class="text-theme">*</span></label> <input type="email" placeholder="Email *" class="form-control"></div> <div class="col-md-4 col-sm-12 col-xs-12"><label class="control-label  visible-xs">Website </label> <input type="text" placeholder="Website" class="form-control"></div></div> <div class="form-group"><div class="col-md-12 col-sm-12 col-xs-12 comment-textarea"><textarea rows="6" placeholder="请使用MarkDown语法编辑，换行请空一行，请不要超过1024个字符" class="form-control" style="overflow-y:hidden;"></textarea> <div class="comment-bottom"><p class="hidden-xs"><span class="emoji">😂</span> <span class="emoji">😫</span> <span class="emoji">😭</span> <span class="emoji">🤣</span> <span class="emoji">😅</span> <span class="emoji">😣</span> <span class="emoji">😍</span> <span class="emoji">🤗</span></p> <span class="submit">提交</span></div></div></div></form></div> <div><div class="media"><div class="media-left"><img src="./一行一行源码分析清楚 AbstractQueuedSynchronizer (二)_files/0.png" alt="" class="media-object img-circle" style="width: 50px; height: 50px;"></div> <div class="media-body"><h5 data-toc-skip="" class="media-heading"><img src="./一行一行源码分析清楚 AbstractQueuedSynchronizer (二)_files/0.png" alt="" class="img-circle" style="display: none; width: 30px; height: 30px;">
                HongJie
                <span class="pull-right">2018-03-26 17:27</span></h5> <p><p>非常抱歉，周末的留言一般我很难及时回复，然后就只能等工作日想起来的时候回复了?</p>
<p>你看得非常细心。初略看了一下，应该是我写错了，后面有时间的时候，我再推敲推敲~~~</p>
</p> <p><a href="javascript:;" class="reply">回复</a> <!----></p> <div class="add-comment nested-comment" style="display: none;"><form class="form-horizontal"><div class="form-group"><div class="col-md-4 col-sm-12 col-xs-12"><label class="control-label visible-xs">Name <span class="text-theme">*</span></label> <input type="text" placeholder="Name *" class="form-control"></div> <div class="col-md-4 col-sm-12 col-xs-12"><label class="control-label visible-xs">Email <span class="text-theme">*</span></label> <input type="email" placeholder="Email *" class="form-control"></div> <div class="col-md-4 col-sm-12 col-xs-12"><label class="control-label  visible-xs">Website </label> <input type="text" placeholder="Website" class="form-control"></div></div> <div class="form-group"><div class="col-md-12 col-sm-12 col-xs-12 comment-textarea"><textarea rows="6" placeholder="请使用MarkDown语法编辑，换行请空一行，请不要超过1024个字符" class="form-control" style="overflow-y:hidden;"></textarea> <div class="comment-bottom"><p class="hidden-xs"><span class="emoji">😂</span> <span class="emoji">😫</span> <span class="emoji">😭</span> <span class="emoji">🤣</span> <span class="emoji">😅</span> <span class="emoji">😣</span> <span class="emoji">😍</span> <span class="emoji">🤗</span></p> <span class="submit">提交</span></div></div></div></form></div> <!----></div></div></div></div></div><div class="media"><div class="media-left"><img src="./一行一行源码分析清楚 AbstractQueuedSynchronizer (二)_files/8.png" alt="" class="media-object img-circle" style="width: 50px; height: 50px;"></div> <div class="media-body"><h5 data-toc-skip="" class="media-heading"><img src="./一行一行源码分析清楚 AbstractQueuedSynchronizer (二)_files/8.png" alt="" class="img-circle" style="display: none; width: 30px; height: 30px;">
                Adrian
                <span class="pull-right">2018-04-02 11:00</span></h5> <p><p>HongJie大哥，您好。在第3节isOnSyncQueue(Node node)方法里面。
文中是：   // 如果 waitStatus 还是 Node.CONDITION，也就是 2，那肯定就是还在条件队列中</p>
<p>这里的Node.CONDITION应该是 -2 才对吧。。。</p>
</p> <p><a href="javascript:;" class="reply">回复</a> <!----></p> <div class="add-comment nested-comment" style="display: none;"><form class="form-horizontal"><div class="form-group"><div class="col-md-4 col-sm-12 col-xs-12"><label class="control-label visible-xs">Name <span class="text-theme">*</span></label> <input type="text" placeholder="Name *" class="form-control"></div> <div class="col-md-4 col-sm-12 col-xs-12"><label class="control-label visible-xs">Email <span class="text-theme">*</span></label> <input type="email" placeholder="Email *" class="form-control"></div> <div class="col-md-4 col-sm-12 col-xs-12"><label class="control-label  visible-xs">Website </label> <input type="text" placeholder="Website" class="form-control"></div></div> <div class="form-group"><div class="col-md-12 col-sm-12 col-xs-12 comment-textarea"><textarea rows="6" placeholder="请使用MarkDown语法编辑，换行请空一行，请不要超过1024个字符" class="form-control" style="overflow-y:hidden;"></textarea> <div class="comment-bottom"><p class="hidden-xs"><span class="emoji">😂</span> <span class="emoji">😫</span> <span class="emoji">😭</span> <span class="emoji">🤣</span> <span class="emoji">😅</span> <span class="emoji">😣</span> <span class="emoji">😍</span> <span class="emoji">🤗</span></p> <span class="submit">提交</span></div></div></div></form></div> <div><div class="media"><div class="media-left"><img src="./一行一行源码分析清楚 AbstractQueuedSynchronizer (二)_files/0.png" alt="" class="media-object img-circle" style="width: 50px; height: 50px;"></div> <div class="media-body"><h5 data-toc-skip="" class="media-heading"><img src="./一行一行源码分析清楚 AbstractQueuedSynchronizer (二)_files/0.png" alt="" class="img-circle" style="display: none; width: 30px; height: 30px;">
                HongJie
                <span class="pull-right">2018-04-02 11:02</span></h5> <p><p>抱歉，犯低级错误了~~~谢谢！</p>
</p> <p><a href="javascript:;" class="reply">回复</a> <!----></p> <div class="add-comment nested-comment" style="display: none;"><form class="form-horizontal"><div class="form-group"><div class="col-md-4 col-sm-12 col-xs-12"><label class="control-label visible-xs">Name <span class="text-theme">*</span></label> <input type="text" placeholder="Name *" class="form-control"></div> <div class="col-md-4 col-sm-12 col-xs-12"><label class="control-label visible-xs">Email <span class="text-theme">*</span></label> <input type="email" placeholder="Email *" class="form-control"></div> <div class="col-md-4 col-sm-12 col-xs-12"><label class="control-label  visible-xs">Website </label> <input type="text" placeholder="Website" class="form-control"></div></div> <div class="form-group"><div class="col-md-12 col-sm-12 col-xs-12 comment-textarea"><textarea rows="6" placeholder="请使用MarkDown语法编辑，换行请空一行，请不要超过1024个字符" class="form-control" style="overflow-y:hidden;"></textarea> <div class="comment-bottom"><p class="hidden-xs"><span class="emoji">😂</span> <span class="emoji">😫</span> <span class="emoji">😭</span> <span class="emoji">🤣</span> <span class="emoji">😅</span> <span class="emoji">😣</span> <span class="emoji">😍</span> <span class="emoji">🤗</span></p> <span class="submit">提交</span></div></div></div></form></div> <!----></div></div></div></div></div><div class="media"><div class="media-left"><img src="./一行一行源码分析清楚 AbstractQueuedSynchronizer (二)_files/3.png" alt="" class="media-object img-circle" style="width: 50px; height: 50px;"></div> <div class="media-body"><h5 data-toc-skip="" class="media-heading"><img src="./一行一行源码分析清楚 AbstractQueuedSynchronizer (二)_files/3.png" alt="" class="img-circle" style="display: none; width: 30px; height: 30px;">
                NJU_YZF
                <span class="pull-right">2018-07-19 10:43</span></h5> <p><p>await()函数里 while (!isOnSyncQueue(node))可以把while换成if吗？为什么需要while？</p>
</p> <p><a href="javascript:;" class="reply">回复</a> <!----></p> <div class="add-comment nested-comment" style="display: none;"><form class="form-horizontal"><div class="form-group"><div class="col-md-4 col-sm-12 col-xs-12"><label class="control-label visible-xs">Name <span class="text-theme">*</span></label> <input type="text" placeholder="Name *" class="form-control"></div> <div class="col-md-4 col-sm-12 col-xs-12"><label class="control-label visible-xs">Email <span class="text-theme">*</span></label> <input type="email" placeholder="Email *" class="form-control"></div> <div class="col-md-4 col-sm-12 col-xs-12"><label class="control-label  visible-xs">Website </label> <input type="text" placeholder="Website" class="form-control"></div></div> <div class="form-group"><div class="col-md-12 col-sm-12 col-xs-12 comment-textarea"><textarea rows="6" placeholder="请使用MarkDown语法编辑，换行请空一行，请不要超过1024个字符" class="form-control" style="overflow-y:hidden;"></textarea> <div class="comment-bottom"><p class="hidden-xs"><span class="emoji">😂</span> <span class="emoji">😫</span> <span class="emoji">😭</span> <span class="emoji">🤣</span> <span class="emoji">😅</span> <span class="emoji">😣</span> <span class="emoji">😍</span> <span class="emoji">🤗</span></p> <span class="submit">提交</span></div></div></div></form></div> <!----></div></div><div class="media"><div class="media-left"><img src="./一行一行源码分析清楚 AbstractQueuedSynchronizer (二)_files/3.png" alt="" class="media-object img-circle" style="width: 50px; height: 50px;"></div> <div class="media-body"><h5 data-toc-skip="" class="media-heading"><img src="./一行一行源码分析清楚 AbstractQueuedSynchronizer (二)_files/3.png" alt="" class="img-circle" style="display: none; width: 30px; height: 30px;">
                NJU_YZF
                <span class="pull-right">2018-07-19 11:46</span></h5> <p><p>如果signal调用了之后，isOnSyncQueue却还是返回false，那么是不是意味着该线程一致阻塞下去？</p>
</p> <p><a href="javascript:;" class="reply">回复</a> <!----></p> <div class="add-comment nested-comment" style="display: none;"><form class="form-horizontal"><div class="form-group"><div class="col-md-4 col-sm-12 col-xs-12"><label class="control-label visible-xs">Name <span class="text-theme">*</span></label> <input type="text" placeholder="Name *" class="form-control"></div> <div class="col-md-4 col-sm-12 col-xs-12"><label class="control-label visible-xs">Email <span class="text-theme">*</span></label> <input type="email" placeholder="Email *" class="form-control"></div> <div class="col-md-4 col-sm-12 col-xs-12"><label class="control-label  visible-xs">Website </label> <input type="text" placeholder="Website" class="form-control"></div></div> <div class="form-group"><div class="col-md-12 col-sm-12 col-xs-12 comment-textarea"><textarea rows="6" placeholder="请使用MarkDown语法编辑，换行请空一行，请不要超过1024个字符" class="form-control" style="overflow-y:hidden;"></textarea> <div class="comment-bottom"><p class="hidden-xs"><span class="emoji">😂</span> <span class="emoji">😫</span> <span class="emoji">😭</span> <span class="emoji">🤣</span> <span class="emoji">😅</span> <span class="emoji">😣</span> <span class="emoji">😍</span> <span class="emoji">🤗</span></p> <span class="submit">提交</span></div></div></div></form></div> <div><div class="media"><div class="media-left"><img src="./一行一行源码分析清楚 AbstractQueuedSynchronizer (二)_files/0.png" alt="" class="media-object img-circle" style="width: 50px; height: 50px;"></div> <div class="media-body"><h5 data-toc-skip="" class="media-heading"><img src="./一行一行源码分析清楚 AbstractQueuedSynchronizer (二)_files/0.png" alt="" class="img-circle" style="display: none; width: 30px; height: 30px;">
                HongJie
                <span class="pull-right">2018-07-25 14:15</span></h5> <p><p>因为 park 方法可能被<strong>假唤醒</strong>，所以碰到 wait(...)、park(...) 这些的时候，基本上都是这么处理</p>
</p> <p><a href="javascript:;" class="reply">回复</a> <!----></p> <div class="add-comment nested-comment" style="display: none;"><form class="form-horizontal"><div class="form-group"><div class="col-md-4 col-sm-12 col-xs-12"><label class="control-label visible-xs">Name <span class="text-theme">*</span></label> <input type="text" placeholder="Name *" class="form-control"></div> <div class="col-md-4 col-sm-12 col-xs-12"><label class="control-label visible-xs">Email <span class="text-theme">*</span></label> <input type="email" placeholder="Email *" class="form-control"></div> <div class="col-md-4 col-sm-12 col-xs-12"><label class="control-label  visible-xs">Website </label> <input type="text" placeholder="Website" class="form-control"></div></div> <div class="form-group"><div class="col-md-12 col-sm-12 col-xs-12 comment-textarea"><textarea rows="6" placeholder="请使用MarkDown语法编辑，换行请空一行，请不要超过1024个字符" class="form-control" style="overflow-y:hidden;"></textarea> <div class="comment-bottom"><p class="hidden-xs"><span class="emoji">😂</span> <span class="emoji">😫</span> <span class="emoji">😭</span> <span class="emoji">🤣</span> <span class="emoji">😅</span> <span class="emoji">😣</span> <span class="emoji">😍</span> <span class="emoji">🤗</span></p> <span class="submit">提交</span></div></div></div></form></div> <!----></div></div><div class="media"><div class="media-left"><img src="./一行一行源码分析清楚 AbstractQueuedSynchronizer (二)_files/0.png" alt="" class="media-object img-circle" style="width: 50px; height: 50px;"></div> <div class="media-body"><h5 data-toc-skip="" class="media-heading"><img src="./一行一行源码分析清楚 AbstractQueuedSynchronizer (二)_files/0.png" alt="" class="img-circle" style="display: none; width: 30px; height: 30px;">
                HongJie
                <span class="pull-right">2018-07-25 14:20</span></h5> <p><p>你这个问题你可以好好考虑一下</p>
</p> <p><a href="javascript:;" class="reply">回复</a> <!----></p> <div class="add-comment nested-comment" style="display: none;"><form class="form-horizontal"><div class="form-group"><div class="col-md-4 col-sm-12 col-xs-12"><label class="control-label visible-xs">Name <span class="text-theme">*</span></label> <input type="text" placeholder="Name *" class="form-control"></div> <div class="col-md-4 col-sm-12 col-xs-12"><label class="control-label visible-xs">Email <span class="text-theme">*</span></label> <input type="email" placeholder="Email *" class="form-control"></div> <div class="col-md-4 col-sm-12 col-xs-12"><label class="control-label  visible-xs">Website </label> <input type="text" placeholder="Website" class="form-control"></div></div> <div class="form-group"><div class="col-md-12 col-sm-12 col-xs-12 comment-textarea"><textarea rows="6" placeholder="请使用MarkDown语法编辑，换行请空一行，请不要超过1024个字符" class="form-control" style="overflow-y:hidden;"></textarea> <div class="comment-bottom"><p class="hidden-xs"><span class="emoji">😂</span> <span class="emoji">😫</span> <span class="emoji">😭</span> <span class="emoji">🤣</span> <span class="emoji">😅</span> <span class="emoji">😣</span> <span class="emoji">😍</span> <span class="emoji">🤗</span></p> <span class="submit">提交</span></div></div></div></form></div> <!----></div></div></div></div></div><div class="media"><div class="media-left"><img src="./一行一行源码分析清楚 AbstractQueuedSynchronizer (二)_files/19.png" alt="" class="media-object img-circle" style="width: 50px; height: 50px;"></div> <div class="media-body"><h5 data-toc-skip="" class="media-heading"><img src="./一行一行源码分析清楚 AbstractQueuedSynchronizer (二)_files/19.png" alt="" class="img-circle" style="display: none; width: 30px; height: 30px;">
                行者
                <span class="pull-right">2018-07-27 15:49</span></h5> <p><p>####大神，请问文章中讲到的生成者-消费者模式，我看很多资料都是定义两个Condition，但我觉得只用一个Condition是不是效果也是一样的，在put的时候检测如果满了则wait，在get的时候检测如果为空则wait，为什么大家都写成两个condition呢，只是为了在名字上区分开两种情况吗？#</p>
</p> <p><a href="javascript:;" class="reply">回复</a> <!----></p> <div class="add-comment nested-comment" style="display: none;"><form class="form-horizontal"><div class="form-group"><div class="col-md-4 col-sm-12 col-xs-12"><label class="control-label visible-xs">Name <span class="text-theme">*</span></label> <input type="text" placeholder="Name *" class="form-control"></div> <div class="col-md-4 col-sm-12 col-xs-12"><label class="control-label visible-xs">Email <span class="text-theme">*</span></label> <input type="email" placeholder="Email *" class="form-control"></div> <div class="col-md-4 col-sm-12 col-xs-12"><label class="control-label  visible-xs">Website </label> <input type="text" placeholder="Website" class="form-control"></div></div> <div class="form-group"><div class="col-md-12 col-sm-12 col-xs-12 comment-textarea"><textarea rows="6" placeholder="请使用MarkDown语法编辑，换行请空一行，请不要超过1024个字符" class="form-control" style="overflow-y:hidden;"></textarea> <div class="comment-bottom"><p class="hidden-xs"><span class="emoji">😂</span> <span class="emoji">😫</span> <span class="emoji">😭</span> <span class="emoji">🤣</span> <span class="emoji">😅</span> <span class="emoji">😣</span> <span class="emoji">😍</span> <span class="emoji">🤗</span></p> <span class="submit">提交</span></div></div></div></form></div> <!----></div></div><div class="media"><div class="media-left"><img src="./一行一行源码分析清楚 AbstractQueuedSynchronizer (二)_files/17.png" alt="" class="media-object img-circle" style="width: 50px; height: 50px;"></div> <div class="media-body"><h5 data-toc-skip="" class="media-heading"><img src="./一行一行源码分析清楚 AbstractQueuedSynchronizer (二)_files/17.png" alt="" class="img-circle" style="display: none; width: 30px; height: 30px;">
                zhongxuan
                <span class="pull-right">2018-07-27 15:56</span></h5> <p><p>"6. 获取独占锁
while 循环出来以后，下面是这段代码：</p>
<p>if (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)
    interruptMode = REINTERRUPT;
由于 while 出来后，我们确定节点已经进入了阻塞队列，准备获取锁。"      这里我看了半天代码，   发现在退出while的时候，就已经获取了独占锁， 也就是说signal 仅仅是transfer 队列，然后由signal的线程unlock释放锁，阻塞队列里的线程获取锁， 所以到了if (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)  的时候，线程早已经获取锁了，这里应该是仅仅设置  savedState  锁状态把？</p>
</p> <p><a href="javascript:;" class="reply">回复</a> <!----></p> <div class="add-comment nested-comment" style="display: none;"><form class="form-horizontal"><div class="form-group"><div class="col-md-4 col-sm-12 col-xs-12"><label class="control-label visible-xs">Name <span class="text-theme">*</span></label> <input type="text" placeholder="Name *" class="form-control"></div> <div class="col-md-4 col-sm-12 col-xs-12"><label class="control-label visible-xs">Email <span class="text-theme">*</span></label> <input type="email" placeholder="Email *" class="form-control"></div> <div class="col-md-4 col-sm-12 col-xs-12"><label class="control-label  visible-xs">Website </label> <input type="text" placeholder="Website" class="form-control"></div></div> <div class="form-group"><div class="col-md-12 col-sm-12 col-xs-12 comment-textarea"><textarea rows="6" placeholder="请使用MarkDown语法编辑，换行请空一行，请不要超过1024个字符" class="form-control" style="overflow-y:hidden;"></textarea> <div class="comment-bottom"><p class="hidden-xs"><span class="emoji">😂</span> <span class="emoji">😫</span> <span class="emoji">😭</span> <span class="emoji">🤣</span> <span class="emoji">😅</span> <span class="emoji">😣</span> <span class="emoji">😍</span> <span class="emoji">🤗</span></p> <span class="submit">提交</span></div></div></div></form></div> <div><div class="media"><div class="media-left"><img src="./一行一行源码分析清楚 AbstractQueuedSynchronizer (二)_files/17.png" alt="" class="media-object img-circle" style="width: 50px; height: 50px;"></div> <div class="media-body"><h5 data-toc-skip="" class="media-heading"><img src="./一行一行源码分析清楚 AbstractQueuedSynchronizer (二)_files/17.png" alt="" class="img-circle" style="display: none; width: 30px; height: 30px;">
                zhongxuan
                <span class="pull-right">2018-07-27 15:58</span></h5> <p><p>不对，应该还有 setHead 等操作。是吧</p>
</p> <p><a href="javascript:;" class="reply">回复</a> <!----></p> <div class="add-comment nested-comment" style="display: none;"><form class="form-horizontal"><div class="form-group"><div class="col-md-4 col-sm-12 col-xs-12"><label class="control-label visible-xs">Name <span class="text-theme">*</span></label> <input type="text" placeholder="Name *" class="form-control"></div> <div class="col-md-4 col-sm-12 col-xs-12"><label class="control-label visible-xs">Email <span class="text-theme">*</span></label> <input type="email" placeholder="Email *" class="form-control"></div> <div class="col-md-4 col-sm-12 col-xs-12"><label class="control-label  visible-xs">Website </label> <input type="text" placeholder="Website" class="form-control"></div></div> <div class="form-group"><div class="col-md-12 col-sm-12 col-xs-12 comment-textarea"><textarea rows="6" placeholder="请使用MarkDown语法编辑，换行请空一行，请不要超过1024个字符" class="form-control" style="overflow-y:hidden;"></textarea> <div class="comment-bottom"><p class="hidden-xs"><span class="emoji">😂</span> <span class="emoji">😫</span> <span class="emoji">😭</span> <span class="emoji">🤣</span> <span class="emoji">😅</span> <span class="emoji">😣</span> <span class="emoji">😍</span> <span class="emoji">🤗</span></p> <span class="submit">提交</span></div></div></div></form></div> <!----></div></div><div class="media"><div class="media-left"><img src="./一行一行源码分析清楚 AbstractQueuedSynchronizer (二)_files/0.png" alt="" class="media-object img-circle" style="width: 50px; height: 50px;"></div> <div class="media-body"><h5 data-toc-skip="" class="media-heading"><img src="./一行一行源码分析清楚 AbstractQueuedSynchronizer (二)_files/0.png" alt="" class="img-circle" style="display: none; width: 30px; height: 30px;">
                HongJie
                <span class="pull-right">2018-07-27 16:42</span></h5> <p><p>感觉你还没有理解透 Condition 的模型，这里只用一个 Condition 是不行的。</p>
<p>还有，要实现生产者-消费者有很多种办法，你可以把其他方式和<strong>两个 Condition 搭配</strong>的做法比较一下。</p>
</p> <p><a href="javascript:;" class="reply">回复</a> <!----></p> <div class="add-comment nested-comment" style="display: none;"><form class="form-horizontal"><div class="form-group"><div class="col-md-4 col-sm-12 col-xs-12"><label class="control-label visible-xs">Name <span class="text-theme">*</span></label> <input type="text" placeholder="Name *" class="form-control"></div> <div class="col-md-4 col-sm-12 col-xs-12"><label class="control-label visible-xs">Email <span class="text-theme">*</span></label> <input type="email" placeholder="Email *" class="form-control"></div> <div class="col-md-4 col-sm-12 col-xs-12"><label class="control-label  visible-xs">Website </label> <input type="text" placeholder="Website" class="form-control"></div></div> <div class="form-group"><div class="col-md-12 col-sm-12 col-xs-12 comment-textarea"><textarea rows="6" placeholder="请使用MarkDown语法编辑，换行请空一行，请不要超过1024个字符" class="form-control" style="overflow-y:hidden;"></textarea> <div class="comment-bottom"><p class="hidden-xs"><span class="emoji">😂</span> <span class="emoji">😫</span> <span class="emoji">😭</span> <span class="emoji">🤣</span> <span class="emoji">😅</span> <span class="emoji">😣</span> <span class="emoji">😍</span> <span class="emoji">🤗</span></p> <span class="submit">提交</span></div></div></div></form></div> <!----></div></div></div></div></div><div class="media"><div class="media-left"><img src="./一行一行源码分析清楚 AbstractQueuedSynchronizer (二)_files/6.png" alt="" class="media-object img-circle" style="width: 50px; height: 50px;"></div> <div class="media-body"><h5 data-toc-skip="" class="media-heading"><img src="./一行一行源码分析清楚 AbstractQueuedSynchronizer (二)_files/6.png" alt="" class="img-circle" style="display: none; width: 30px; height: 30px;">
                show tables;
                <span class="pull-right">2018-08-07 16:57</span></h5> <p><p>show tables;</p>
</p> <p><a href="javascript:;" class="reply">回复</a> <!----></p> <div class="add-comment nested-comment" style="display: none;"><form class="form-horizontal"><div class="form-group"><div class="col-md-4 col-sm-12 col-xs-12"><label class="control-label visible-xs">Name <span class="text-theme">*</span></label> <input type="text" placeholder="Name *" class="form-control"></div> <div class="col-md-4 col-sm-12 col-xs-12"><label class="control-label visible-xs">Email <span class="text-theme">*</span></label> <input type="email" placeholder="Email *" class="form-control"></div> <div class="col-md-4 col-sm-12 col-xs-12"><label class="control-label  visible-xs">Website </label> <input type="text" placeholder="Website" class="form-control"></div></div> <div class="form-group"><div class="col-md-12 col-sm-12 col-xs-12 comment-textarea"><textarea rows="6" placeholder="请使用MarkDown语法编辑，换行请空一行，请不要超过1024个字符" class="form-control" style="overflow-y:hidden;"></textarea> <div class="comment-bottom"><p class="hidden-xs"><span class="emoji">😂</span> <span class="emoji">😫</span> <span class="emoji">😭</span> <span class="emoji">🤣</span> <span class="emoji">😅</span> <span class="emoji">😣</span> <span class="emoji">😍</span> <span class="emoji">🤗</span></p> <span class="submit">提交</span></div></div></div></form></div> <!----></div></div><div class="media"><div class="media-left"><img src="./一行一行源码分析清楚 AbstractQueuedSynchronizer (二)_files/16.png" alt="" class="media-object img-circle" style="width: 50px; height: 50px;"></div> <div class="media-body"><h5 data-toc-skip="" class="media-heading"><img src="./一行一行源码分析清楚 AbstractQueuedSynchronizer (二)_files/16.png" alt="" class="img-circle" style="display: none; width: 30px; height: 30px;">
                huangchengxiang
                <span class="pull-right">2018-09-06 19:43</span></h5> <p><p>好难啊，看的脑瓜仁疼</p>
</p> <p><a href="javascript:;" class="reply">回复</a> <!----></p> <div class="add-comment nested-comment" style="display: none;"><form class="form-horizontal"><div class="form-group"><div class="col-md-4 col-sm-12 col-xs-12"><label class="control-label visible-xs">Name <span class="text-theme">*</span></label> <input type="text" placeholder="Name *" class="form-control"></div> <div class="col-md-4 col-sm-12 col-xs-12"><label class="control-label visible-xs">Email <span class="text-theme">*</span></label> <input type="email" placeholder="Email *" class="form-control"></div> <div class="col-md-4 col-sm-12 col-xs-12"><label class="control-label  visible-xs">Website </label> <input type="text" placeholder="Website" class="form-control"></div></div> <div class="form-group"><div class="col-md-12 col-sm-12 col-xs-12 comment-textarea"><textarea rows="6" placeholder="请使用MarkDown语法编辑，换行请空一行，请不要超过1024个字符" class="form-control" style="overflow-y:hidden;"></textarea> <div class="comment-bottom"><p class="hidden-xs"><span class="emoji">😂</span> <span class="emoji">😫</span> <span class="emoji">😭</span> <span class="emoji">🤣</span> <span class="emoji">😅</span> <span class="emoji">😣</span> <span class="emoji">😍</span> <span class="emoji">🤗</span></p> <span class="submit">提交</span></div></div></div></form></div> <!----></div></div><div class="media"><div class="media-left"><img src="./一行一行源码分析清楚 AbstractQueuedSynchronizer (二)_files/12.png" alt="" class="media-object img-circle" style="width: 50px; height: 50px;"></div> <div class="media-body"><h5 data-toc-skip="" class="media-heading"><img src="./一行一行源码分析清楚 AbstractQueuedSynchronizer (二)_files/12.png" alt="" class="img-circle" style="display: none; width: 30px; height: 30px;">
                琴弦子
                <span class="pull-right">2018-09-10 22:19</span></h5> <p><p>lock.lock();  // 当前线程获取锁
try{
notEmpty.await();  //当前线程（当前线程正在运行）加入到notEmpty条件的等待队列中（加入到队列最尾端），当前线程释放锁和CPU执行权。await()包含unlock()的功能（完全释放锁）
…
}finally{
    lock.unlock(); //当前线程释放锁
}
notEmpty.await();  执行后，完全释放锁（即锁是空闲状态，锁的state=0），finally块在调用lock.unlock();后，锁的state知不是小于0（我分析state=-1），锁岂不是未空闲？</p>
</p> <p><a href="javascript:;" class="reply">回复</a> <!----></p> <div class="add-comment nested-comment" style="display: none;"><form class="form-horizontal"><div class="form-group"><div class="col-md-4 col-sm-12 col-xs-12"><label class="control-label visible-xs">Name <span class="text-theme">*</span></label> <input type="text" placeholder="Name *" class="form-control"></div> <div class="col-md-4 col-sm-12 col-xs-12"><label class="control-label visible-xs">Email <span class="text-theme">*</span></label> <input type="email" placeholder="Email *" class="form-control"></div> <div class="col-md-4 col-sm-12 col-xs-12"><label class="control-label  visible-xs">Website </label> <input type="text" placeholder="Website" class="form-control"></div></div> <div class="form-group"><div class="col-md-12 col-sm-12 col-xs-12 comment-textarea"><textarea rows="6" placeholder="请使用MarkDown语法编辑，换行请空一行，请不要超过1024个字符" class="form-control" style="overflow-y:hidden;"></textarea> <div class="comment-bottom"><p class="hidden-xs"><span class="emoji">😂</span> <span class="emoji">😫</span> <span class="emoji">😭</span> <span class="emoji">🤣</span> <span class="emoji">😅</span> <span class="emoji">😣</span> <span class="emoji">😍</span> <span class="emoji">🤗</span></p> <span class="submit">提交</span></div></div></div></form></div> <!----></div></div><div class="media"><div class="media-left"><img src="./一行一行源码分析清楚 AbstractQueuedSynchronizer (二)_files/4.png" alt="" class="media-object img-circle" style="width: 50px; height: 50px;"></div> <div class="media-body"><h5 data-toc-skip="" class="media-heading"><img src="./一行一行源码分析清楚 AbstractQueuedSynchronizer (二)_files/4.png" alt="" class="img-circle" style="display: none; width: 30px; height: 30px;">
                lv_
                <span class="pull-right">2018-09-13 22:25</span></h5> <p><p>你好，你工作几年了，看了你的文章，我突然感觉自己什么都不会.</p>
</p> <p><a href="javascript:;" class="reply">回复</a> <!----></p> <div class="add-comment nested-comment" style="display: none;"><form class="form-horizontal"><div class="form-group"><div class="col-md-4 col-sm-12 col-xs-12"><label class="control-label visible-xs">Name <span class="text-theme">*</span></label> <input type="text" placeholder="Name *" class="form-control"></div> <div class="col-md-4 col-sm-12 col-xs-12"><label class="control-label visible-xs">Email <span class="text-theme">*</span></label> <input type="email" placeholder="Email *" class="form-control"></div> <div class="col-md-4 col-sm-12 col-xs-12"><label class="control-label  visible-xs">Website </label> <input type="text" placeholder="Website" class="form-control"></div></div> <div class="form-group"><div class="col-md-12 col-sm-12 col-xs-12 comment-textarea"><textarea rows="6" placeholder="请使用MarkDown语法编辑，换行请空一行，请不要超过1024个字符" class="form-control" style="overflow-y:hidden;"></textarea> <div class="comment-bottom"><p class="hidden-xs"><span class="emoji">😂</span> <span class="emoji">😫</span> <span class="emoji">😭</span> <span class="emoji">🤣</span> <span class="emoji">😅</span> <span class="emoji">😣</span> <span class="emoji">😍</span> <span class="emoji">🤗</span></p> <span class="submit">提交</span></div></div></div></form></div> <!----></div></div></div>

<div id="vNewComment" class="add-comment"><h4 data-toc-skip="" style="color: rgb(86, 148, 202);">留下你的评论呗</h4> <form class="form-horizontal"><div class="form-group"><div class="col-md-4"><label class="control-label">Name <span class="text-theme">*</span></label> <input type="text" required="required" class="form-control"></div> <div class="col-md-4"><label class="control-label">Email <span class="text-theme">*</span>（仅用于回复通知）</label> <input type="email" required="required" class="form-control"></div> <div class="col-md-4"><label class="control-label">Website</label> <input type="url" class="form-control"></div></div> <div class="form-group"><div class="col-md-12"><label class="control-label">Comment <span class="text-theme">*</span></label> <textarea rows="6" required="required" placeholder="请使用MarkDown语法编辑，换行请空一行，请不要超过1024个字符" class="form-control" style="overflow-y:hidden;"></textarea></div></div> <div class="form-group"><div class="col-md-12"><button type="submit" class="btn btn-theme">Post Comment</button></div></div></form></div>

<script type="text/x-template" id="comment-template">
    <div class="media">
        <div class="media-left" v-show="model.depth < 4">
            <img class="media-object img-circle" style="width: 50px; height: 50px;"
                 v-bind:src="'https://www.javadoop.com/blogimages/headimgs/' + (model.head) + '.png'" alt="">
        </div>
        <div class="media-body">
            <h5 data-toc-skip class="media-heading">
                <img v-show="model.depth > 3" class="img-circle" style="display: inline; width: 30px; height: 30px;"
                     v-bind:src="'https://www.javadoop.com/blogimages/headimgs/' + (model.head) + '.png'" alt=""/>
                {{model.username}}
                <span class="pull-right">{{model.createTime | formatDate}}</span>
            </h5>
            <p v-html="model.content"></p>
            <p>
                <a href="javascript:;" class="reply" @click="toggleCommentArea" v-if="!this.showCommentArea">回复</a>
                <a href="javascript:;" class="reply" @click="toggleCommentArea" v-if="this.showCommentArea">取消</a>
            </p>

            <div class="add-comment nested-comment" v-show='showCommentArea'>
                <form class="form-horizontal">
                    <div class="form-group">
                        <div class="col-md-4 col-sm-12 col-xs-12">
                            <label class="control-label visible-xs">Name <span class="text-theme">*</span></label>
                            <input type="text" class="form-control" placeholder="Name *"
                                   v-model='currentuser.username'>
                        </div>
                        <div class="col-md-4 col-sm-12 col-xs-12">
                            <label class="control-label visible-xs">Email <span class="text-theme">*</span></label>
                            <input type="email" class="form-control" placeholder="Email *"
                                   v-model='currentuser.email'>
                        </div>
                        <div class="col-md-4 col-sm-12 col-xs-12">
                            <label class="control-label  visible-xs">Website </label>
                            <input type="text" class="form-control" placeholder="Website" v-model='currentuser.website'>
                        </div>
                    </div>
                    <div class="form-group">
                        <div class="col-md-12 col-sm-12 col-xs-12 comment-textarea">
                            <textarea class="form-control" rows="6" v-model='commentText' placeholder="请使用MarkDown语法编辑，换行请空一行，请不要超过1024个字符"></textarea>
                            
                                
                                    
                                    
                                    
                                    
                                    
                                    
                                    
                                    
                                    
                                    
                                    
                                
                                
                            
                            <div class="comment-bottom">
                                <p class="hidden-xs">
                                    <span class="emoji" @click="insertEmoji('😂')">😂</span>
                                    <span class="emoji" @click="insertEmoji('😫')">😫</span>
                                    <span class="emoji" @click="insertEmoji('😭')">😭</span>
                                    <span class="emoji" @click="insertEmoji('🤣')">🤣</span>
                                    <span class="emoji" @click="insertEmoji('😅')">😅</span>
                                    <span class="emoji" @click="insertEmoji('😣')">😣</span>
                                    <span class="emoji" @click="insertEmoji('😍')">😍</span>
                                    <span class="emoji" @click="insertEmoji('🤗')">🤗</span>
                                </p>
                                
                                <span class="submit" @click="submit">提交</span>
                            </div>
                        </div>
                    </div>
                </form>
            </div>

            <div v-if='hasChildren'>
                <comment v-for="(model, index) in model.children" :model='model' :idx="index"
                         :size="model.children.length" :currentuser="currentuser"></comment>
            </div>

        </div>
    </div>
</script>
<script>

    Vue.filter('formatDate', function (value) {
        if (value) {
            var delta = (new Date().getTime() - value) / 1000;
            if (delta < 60) {
                return "刚刚";
            } else if (delta / 60 < 60) {
                return (parseInt(delta / 60)) + " 分钟前";
            } else if (delta / 3600 < 24) {
                return (parseInt(delta / 3600)) + " 小时前";
            } else {
                var date = new Date(value);
                return date.getFullYear() + "-" + (addZero(date.getMonth() + 1)) + "-" + addZero(date.getDate()) + " " + addZero(date.getHours()) + ":" + addZero(date.getMinutes());
            }
        }
    });

    Vue.component("comment", {
        template: '#comment-template',
        props: ["model", "idx", "size", "currentuser"],
        data: function () {
            return {
                showCommentArea: false,
                commentText: ""
            }
        },
        computed: {
            hasChildren: function () {
                return this.model.children && this.model.children.length;
            }
        },
        methods: {
            toggle: function () {
                if (this.hasChildren) {
                    this.model.open = !this.model.open;
                }
            },
            toggleCommentArea: function () {
                this.showCommentArea = !this.showCommentArea;
            },
            insertEmoji: function (emoji) {
                var $text = $(event.target).parents('.comment-bottom').prev('textarea');
                var cursorPos = $text.prop('selectionStart');
                var v = $text.val();

                var textBefore = v.substring(0, cursorPos);
                var textAfter = v.substring(cursorPos, v.length);

                this.commentText = textBefore + emoji + textAfter;
            },
            submit: function () {
                var _this = this;

                var parentId = _this.model.id;

                if (_this.commentText.length > 1024) {
                    alert("要不评论内容写少一点？");
                    return false;
                }
                ajaxRequest("POST", "/comment/createComment", {
                    postId: 2,
                    parentId: parentId,
                    content: _this.commentText,
                    username: _this.currentuser.username,
                    email: _this.currentuser.email,
                    website: _this.currentuser.website
                }, function (comment) {
//                    showSuccessNotify("评论成功");
                    _this.showCommentArea = false;
                    _this.model.children.unshift(comment);
                    _this.commentText = "";
                    $.cookie("username", _this.currentuser.username, {expires: 1000, path: '/'});
                    $.cookie("email", _this.currentuser.email, {expires: 1000, path: '/'});
                    $.cookie("website", _this.currentuser.website, {expires: 1000, path: '/'});
                    setTimeout(function () {
                        $('.comments-block pre code').each(function (i, block) {
                            hljs.highlightBlock(block);
                        });
                    }, 200)
                });
            }
        },
        updated: function () {
            // 性能不行
//            $('pre code').each(function (i, block) {
//                hljs.highlightBlock(block);
//            });
        }
    });
    var Vcomment = new Vue({
        el: '#vcomments',
        data: {
            commentsdata: [],
            currentuser: {}
        },
        updated: function () {
//            showSuccessNotify("updated")
            $('pre code').each(function (i, block) {
                hljs.highlightBlock(block);
            });
        }
    });

    var VnewComment = new Vue({
        el: '#vNewComment',
        data: {
            commentText: "",
            username: "",
            email: "",
            website: ""
        },
        methods: {
            submit: function () {
                var _this = this;

                if (_this.commentText.length > 1024) {
                    alert("要不评论内容写少一点？");
                    return false;
                }
                if (_this.username.length == 0) {
                    alert("请输入 name，便于评论显示");
                    return false;
                }
                if (_this.email.length == 0) {
                    alert("请输入 email，便于可能的联系");
                    return false;
                }
                ajaxRequest("POST", "/comment/createComment", {
                    postId: 2,
                    content: _this.commentText,
                    username: _this.username,
                    email: _this.email,
                    website: _this.website
                }, function (comment) {
                    alert("评论成功");
                    Vcomment.commentsdata.push({
                        createTime: comment.createTime,
                        content: comment.content,
                        head: comment.head,
                        depth: comment.depth,
                        username: comment.username,
                        children: []
                    });
                    Vcomment.currentuser.username = _this.username;
                    Vcomment.currentuser.email = _this.email;
                    Vcomment.currentuser.website = _this.website;

                    _this.commentText = "";
                    $.cookie("username", _this.username, {expires: 1000, path: '/'});
                    $.cookie("email", _this.email, {expires: 1000, path: '/'});
                    $.cookie("website", _this.website, {expires: 1000, path: '/'});
                    setTimeout(function () {
                        $('.comments-block pre code').each(function (i, block) {
                            hljs.highlightBlock(block);
                        });
                    }, 200)
                });
            }
        }
    });


    ajaxRequest("GET", "/comment/listComment", {postId: 2}, function (data) {
        Vcomment.commentsdata = data.comments;
    });
    ajaxRequest("GET", "/user/getUserInfo", {}, function (data) {
        if (data != null) {
            Vcomment.currentuser = data;

            VnewComment.username = data.username;
            VnewComment.email = data.email;
            VnewComment.website = data.website;
        } else {
            Vcomment.currentuser.username = $.cookie("username");
            Vcomment.currentuser.email = $.cookie("email");
            Vcomment.currentuser.website = $.cookie("website");

            VnewComment.username = $.cookie("username");
            VnewComment.email = $.cookie("email");
            VnewComment.website = $.cookie("website");
        }
    });



    function ajaxRequest(reqtype, actionUrl, actionData, callback, asy) {
        $.ajax({
            type: reqtype || "GET",
            url: actionUrl,
            cache: false,
            data: actionData,
            async: asy || false,
            success: function (response) {
                if (response.result) {
                    callback(response.data);
                } else {
                    alert(response.message);
                }
            },
            error: function (result) {
                console.log(result)
            },
            complete: function (xhr) {
                if (xhr.status == 401) {
                    alert("请登录后再操作")
                    // Vlogin.showModal = true;
                } else if (xhr.sta == 404) {
                    alert("请求地址错误");
                }
            }
        });
    }
    function addZero(v) {
        if (v < 10) {
            return '0' + v;
        } else {
            return v + "";
        }
    }
</script>
            </div>

            <hr class="hidden-xs">
            <p class="pull-right hidden-xs">Copyright © 2018 JavaDoop 联系我: hongjie.v#gmail.com</p>

        </div>
    </div>
    <a href="javascript:;" id="settings" title="settings" class="show" onclick="toggleSettings()">
        <i class="glyphicon glyphicon-cog"></i>
    </a>
    <a href="https://javadoop.com/post/AbstractQueuedSynchronizer-2#" id="back-to-top" title="Back to top" class="">
        <i class="glyphicon glyphicon-chevron-up"></i>
    </a>
</div>
<div id="settings-panel" style="display: none;"><div class="line"><button style="width: 50%;">待开发</button> <button style="width: 50%;">显示导航</button></div> <div class="line"><button style="width: 50%; font-size: 14px;">A</button> <button style="width: 50%; font-size: 16px;">A</button></div> <div class="line"><button style="width: 50%;">PingFang</button> <button style="width: 50%;">Helvetica</button></div> <div class="line" style="border-bottom: 0px;"><button style="width: 33%;">Night</button> <button style="width: 33%;">Cat</button> <button style="width: 33%;">Light</button></div></div>

<script src="./一行一行源码分析清楚 AbstractQueuedSynchronizer (二)_files/javadoop-toc-spy.js"></script>
<script>
    $(function () {


        $('pre code').each(function (i, block) {
            hljs.highlightBlock(block);
        });

        $('.comment-textarea textarea').each(function () {
            this.setAttribute('style', 'overflow-y:hidden;');
        }).on('input', function () {
            this.style.height = 'auto';
            this.style.height = (this.scrollHeight + 40) + 'px';
        });

        $("#vNewComment textarea").each(function () {
            this.setAttribute('style', 'overflow-y:hidden;');
        }).on("input", function () {
            this.style.height = 'auto';
            this.style.height = (this.scrollHeight) + 'px';
        });

        if ($('#back-to-top').length) {
            var scrollTrigger = 800,
                backToTop = function () {
                    var scrollTop = $(window).scrollTop();
                    if (scrollTop > scrollTrigger) {
                        $('#back-to-top').addClass('show');
                    } else {
                        $('#back-to-top').removeClass('show');
                    }
                };
            backToTop();
            $(window).on('scroll', function () {
                backToTop();
            });
            $('#back-to-top').on('click', function (e) {
                e.preventDefault();
                $('html,body').animate({
                    scrollTop: 0
                }, 700);
            });
        }
        $("body").on('click', function (event) {
            if (!$(event.target).closest('#settings-panel').length && !$(event.target).closest('#settings').length) {
                vSettings.$data.showSettings = false;
            }
        });
    });

    function toggleSettings() {
        vSettings.$data.showSettings = !vSettings.$data.showSettings;
    }

    var vSettings = new Vue({
        el: "#settings-panel",
        data: {
            fontSize: 14,
            fontFamily: 'Helvetica',
            theme: 'white',
            showSettings: false,
            toggleTocText: "显示导航"
        },
        created: function () {
            var cachedTheme = $.cookie("theme-2051");
            if (cachedTheme) {
                this.theme = cachedTheme;
                $("body").attr("class", cachedTheme);
            }

            this.fontSize = parseInt($("body").css("font-size"));
            var cachedFontSize = $.cookie("fontSize");
            if (cachedFontSize) {
                this.fontSize = cachedFontSize;
                $("body").css("font-size", cachedFontSize + "px");
            }

            var cachedFamily = $.cookie("fontFamily");
            if (cachedFamily) {
                this.fontFamily = cachedFamily;
                if (cachedFamily == 'Helvetica') {
                    var val = '"Helvetica Neue", "Hiragino Sans GB", "Microsoft YaHei", Arial, sans-serif';
                    $("body").css("font-family", val);
                } else {
                    var val = "PingFang SC,-apple-system,BlinkMacSystemFont,Helvetica Neue,Microsoft YaHei,Source Han Sans SC,Noto Sans CJK SC,WenQuanYi Micro Hei,sans-serif";
                    $("body").css("font-family", val);
                }
            }
        },
        watch: {
            fontSize: function (fontSize) {
                if (fontSize > 20) {
                    this.fontSize = 20;
                }
                if (fontSize < 10) {
                    this.fontSize = 10;
                }
                $.cookie("fontSize", this.fontSize);
                $("body").css("font-size", this.fontSize + "px");
            },
            fontFamily: function (f) {
                if (f == 'Helvetica') {
                    var val = '"Helvetica Neue", "Hiragino Sans GB", "Microsoft YaHei", Arial, sans-serif';
                    $("body").css("font-family", val);
                } else {
                    var val = "PingFang SC,-apple-system,BlinkMacSystemFont,Helvetica Neue,Microsoft YaHei,Source Han Sans SC,Noto Sans CJK SC,WenQuanYi Micro Hei,sans-serif";
                    $("body").css("font-family", val);
                }
                $.cookie("fontFamily", f);
            },
            theme: function (t) {
                $.cookie("theme-2051", t);
                $("body").attr("class", t);
            }
        },
        methods: {
            toggleToc: function () {
                console.log("toggle toc")
                var marginLeft = $("body").css("margin-left");
                if (parseInt(marginLeft)) {
                    // 当前有toc,去掉toc
                    $("body").css("margin-left", "0");
                    $("#content").removeClass("showToc");
                    $("#toc").hide(700);
                    this.toggleTocText = "显示导航";
                } else {
                    $("body").css("margin-left", "300px");
                    $("#content").addClass("showToc");
                    $("#toc").show(700);
                    $('body').scrollspy("refresh");
                    this.toggleTocText = "隐藏导航";
                }
            }
        }
    })

</script>
<script>
    //    var _hmt = _hmt || [];
    //    (function () {
    //        var hm = document.createElement("script");
    //        hm.src = "https://hm.baidu.com/hm.js?edf6136c3e6c4fc0960cbbe3ebdd9cc4";
    //        var s = document.getElementsByTagName("script")[0];
    //        s.parentNode.insertBefore(hm, s);
    //    })();
    window.console && window.console.log && console.log("以此主题怀念那些过去的岁月~~~");
</script>


</body></html>